(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.translateContract = translateContract;
exports.createNewContractString = createNewContractString;
exports.Contract = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @author Noah-Vincenz Noeh <noah-vincenz.noeh18@imperial.ac.uk>
 */

/* jshint esversion: 6 */

/**
 * This represents a contract object that is used as an intermediated representation to be stored and processed when acquired.
 */
var Contract = function Contract(id, amount, observablesArr, recipient, contractString, meaningOfContractString, horizonDate, toBeExecutedAtHorizon, status) {
  _classCallCheck(this, Contract);

  this.id = id;
  this.amount = amount;
  this.observablesArr = observablesArr;
  this.recipient = recipient;
  this.contractString = contractString;
  this.meaningOfContractString = meaningOfContractString;
  this.horizonDate = horizonDate;
  this.toBeExecutedAtHorizon = toBeExecutedAtHorizon;
  this.status = status;
};
/**
 * Translates a contract into a human-readable format using the contract's attributes
 * @param {string} recipient - The contract recipient.
 * @param {string} amount - The amount to be transferred.
 * @param {array} observablesArr - The array that is used to translate optional observables that the contract may contain.
 * @param {string} horizonDate - The horizon of the contract.
 * @param {string} acquireAtHorizon - A string that specifies whether the contract should be acquired at its horizon ("yes").
 * @returns {string} The human-readable meaning of the contract.
 */


exports.Contract = Contract;

function translateContract(recipient, amount, observablesArr, horizonDate, acquireAtHorizon) {
  var to = "holder";
  var from = "counter-party";
  var hDate = "";

  if (recipient === 1) {
    to = "counter-party";
    from = "holder";
  }

  if (horizonDate !== "infinite") {
    if (acquireAtHorizon === "yes") {
      hDate = " at " + horizonDate;
    } else {
      hDate = " before " + horizonDate;
    }
  }

  var adj = " is";

  if (parseFloat(amount) !== 1) {
    if (parseFloat(amount) === 0) {
      adj = " are";
    } else {
      adj = "s are";
    }
  }

  if (observablesArr.length > 0 && amount !== "0") {
    for (var i = 0; i < observablesArr.length; ++i) {
      amount = amount + "x" + observablesArr[i];
    }

    adj = "s are";
  }

  return amount + " Ether" + adj + " transferred from the " + from + " address to the " + to + " address" + hDate + ".";
}
/**
 * Creates a standardised contract string that acts as an intermediated representation of our language using the contract's attributes
 * @param {string} amount - The amount to be transferred.
 * @param {array} obsArr - The array that is used to translate optional observables that the contract may contain.
 * @param {string} recipient - The contract recipient.
 * @param {string} horizonDate - The horizon of the contract.
 * @param {string} acquireAtHorizon - A string that specifies whether the contract should be acquired at its horizon ("yes").
 * @returns {string} The human-readable meaning of the contract.
 */


function createNewContractString(amount, obsArr, recipient, horizonDate, acquireAtHorizon) {
  var stringToReturn = "";

  if (amount === "0") {
    stringToReturn = "zero";
  } else if (amount === "1" && obsArr.length === 0) {
    stringToReturn = "one";
  } else {
    if (obsArr.length > 0) {
      for (var i = 0; i < obsArr.length; ++i) {
        amount = amount + "x" + observablesArr[i];
      }
    }

    stringToReturn = "scaleK " + amount + " ( one )";
  }

  if (horizonDate !== "infinite") {
    stringToReturn = "truncate " + horizonDate + " ( " + stringToReturn + " )";
  }

  if (recipient === 1) {
    stringToReturn = "give ( " + stringToReturn + " )";
  }

  if (acquireAtHorizon === "yes") {
    stringToReturn = "get ( " + stringToReturn + " )";
  }

  return stringToReturn;
}

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedMetaMaskAccount = getSelectedMetaMaskAccount;
exports.getSelectedNetwork = getSelectedNetwork;
exports.setDefaultAccount = setDefaultAccount;
exports.setSmartContractInstance = setSmartContractInstance;
exports.unlockAccount = unlockAccount;
exports.instantiateNew = instantiateNew;
exports.depositCollateral = depositCollateral;
exports.holderBalance = holderBalance;
exports.counterPartyBalance = counterPartyBalance;
exports.holderAddress = holderAddress;
exports.counterPartyAddress = counterPartyAddress;
exports.balanceOfAddress = balanceOfAddress;
exports.watchTransferEvent = watchTransferEvent;
exports.transfer = transfer;
exports.waitForReceipt = waitForReceipt;

var _resources = require("./resources.mjs");

/**
 * @author Noah-Vincenz Noeh <noah-vincenz.noeh18@imperial.ac.uk>
 */

/* jshint esversion: 6 */
var abi;
var codeHex;
var smartContract;
var smartContractInstance;
/**
 * This is called when the web page is loaded and is used for initialising important system components.
 */

window.addEventListener('load', function () {
  // Modern DApp Browsers
  if (window.ethereum) {
    web3 = new Web3(window.ethereum);

    try {
      window.ethereum.enable().then(function () {
        // User has allowed account access to DApp...
        console.log("user has allowed account access to DApp");
        abi = _resources.ABI;
        codeHex = web3.toHex(_resources.CODE_HEX);
        smartContract = web3.eth.contract(abi);
      });
    } catch (e) {
      // User has denied account access to DApp...
      console.log("user has denied account access to DApp");
    }
  } // Legacy DApp Browsers
  else if (window.web3) {
      web3 = new Web3(web3.currentProvider);
      abi = _resources.ABI;
      codeHex = web3.toHex(_resources.CODE_HEX);
      smartContract = web3.eth.contract(abi);
    } // Non-DApp Browsers
    else {
        console.log('No Web3 Detected... using HTTP Provider');
        web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
      }
});
/**
 * This returns the address of the currently selecte MetaMask account.
 */

function getSelectedMetaMaskAccount() {
  return web3.eth.accounts[0];
}
/**
 * This returns the currently selected network.
 */


function getSelectedNetwork() {
  return web3.version.network;
}
/**
 * This is used to set the default account of web3.
 */


function setDefaultAccount(address) {
  web3.eth.defaultAccount = address;
}
/**
 * This is used to set the smartContractInstance variable.
 */


function setSmartContractInstance(contractAddress) {
  smartContractInstance = smartContract.at(contractAddress);
}
/**
 * Unlocks accounts.
 * @param {string} address - The address specifying the account to be unlocked.
 */


function unlockAccount(address) {
  // this does not exist for Kovan chain
  return new Promise(function (resolve, reject) {
    web3.personal.unlockAccount(address, "user", web3.toHex(0), function (err, result) {
      if (err) {
        reject(err);
      } else {
        console.log("Account has been unlocked: " + JSON.stringify(result));
        resolve();
      }
    });
  });
}
/**
 * Instantiates a new Rust smart contract instance.
 * @param {string} holderAddress - The address specifying the contract holder.
 * @param {string} counterPartyAddress - The address specifying the contract counter-party.
 */


function instantiateNew(holderAddress, counterPartyAddress) {
  return new Promise(function (resolve, reject) {
    smartContract["new"](holderAddress, counterPartyAddress, {
      data: codeHex,
      from: web3.eth.defaultAccount
    }, function (err, contractInstance) {
      //smartContract.new({data: dataIn, from: web3.eth.defaultAccount, gasPrice: 4000000000, gas: gasLimit}, function (err, contractInstance) {
      if (err) {
        reject(err);
      } else {
        var transactionHash = contractInstance.transactionHash;
        console.log("TransactionHash: " + transactionHash + " waiting to be mined...");
        resolve(transactionHash);
      }
    });
  });
}
/**
 * This transfers Ether between two addresses outside of our Rust contract.
 * @param {string} fromAddress - The address specifying the sender.
 * @param {string} toAddress - The address specifying the recipient.
 * @param {number} amount - The amount to be transferred.
 */


function transferEtherExternally(fromAddress, toAddress, amount) {
  web3.eth.sendTransaction({
    from: fromAddress,
    to: toAddress,
    value: web3.toWei(amount, "ether")
  }, function (error, hash) {
    if (error) {
      console.log(error);
    }
  });
}
/**
 * Deposits a given amount of Ether into a given account.
 * @param {string} senderAddress - The address specifying the account to be used for the deposit.
 * @param {number} amount - The amount to be deposited.
 */


function depositCollateral(senderAddress, amount) {
  return new Promise(function (resolve, reject) {
    smartContractInstance.depositCollateral(amount, {
      from: senderAddress,
      value: web3.toWei(amount, "ether")
    }, function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(result.toString(10));
      }
    });
  });
}
/**
 * Used to retrieve the balance of the contract holder.
 */


function holderBalance() {
  return new Promise(function (resolve, reject) {
    smartContractInstance.holderBalance(function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(web3.toDecimal(result));
      }
    });
  });
}
/**
 * Used to retrieve the balance of the contract counter-party.
 */


function counterPartyBalance() {
  return new Promise(function (resolve, reject) {
    smartContractInstance.counterPartyBalance(function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(web3.toDecimal(result));
      }
    });
  });
}
/**
 * Used to retrieve the address of the contract holder.
 */


function holderAddress() {
  return new Promise(function (resolve, reject) {
    smartContractInstance.holderAddress(function (err, result) {
      if (err) {
        reject(err);
      } else {
        var unpaddedAddr = web3.toHex(result.toString(10)); // pad address to length of 42

        var paddedAddr = unpaddedAddr.split("0x")[1].padStart(40, '0');
        resolve("0x" + paddedAddr);
      }
    });
  });
}
/**
 * Used to retrieve the address of the contract counterparty.
 */


function counterPartyAddress() {
  return new Promise(function (resolve, reject) {
    smartContractInstance.counterPartyAddress(function (err, result) {
      if (err) {
        reject(err);
      } else {
        var unpaddedAddr = web3.toHex(result.toString(10)); // pad address to length of 42

        var paddedAddr = unpaddedAddr.split("0x")[1].padStart(40, '0');
        resolve("0x" + paddedAddr);
      }
    });
  });
}
/**
 * Used to retrieve the balance of a given address.
 * @param {string} address - The address specifying the account balanced to be retrieved.
 */


function balanceOfAddress(address) {
  return new Promise(function (resolve, reject) {
    smartContractInstance.balanceOfAddress(web3.toChecksumAddress(address), function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(web3.toDecimal(result));
      }
    });
  });
}
/**
 * Used to watch the TransferEvent defined in our Rust smart contract definition.
 */


function watchTransferEvent() {
  return new Promise(function (resolve, reject) {
    smartContractInstance.TransferEvent({}, function (err, event) {
      if (err) {
        reject(err);
      } else {
        resolve(event.args.result); // returns ints regarding state of transfer
      }
    });
  });
}
/**
 * Used to transfer Ether between two accounts.
 * @param {string} fromAddress - The address specifying the sender.
 * @param {string} toAddress - The address specifying the recipient.
 * @param {string} amount - The amount of Ether to be transferred.
 */


function transfer(fromAddress, toAddress, amount) {
  return new Promise(function (resolve, reject) {
    smartContractInstance.transfer(fromAddress, toAddress, amount, function (err, result) {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}
/**
 * Used to wait for a transaction's receipt. This is useful when one needs
 * to respond to a Rust smart contract event and update the UI correspondingly.
 * @param {string} transactionHash - The hash specifying the transaction to be waited for.
 */


function waitForReceipt(transactionHash) {
  return new Promise(function (resolve, reject) {
    web3.eth.getTransactionReceipt(transactionHash, function (err, receipt) {
      if (err) {
        reject(err);
      } else {
        if (receipt !== null) {
          // Transaction went through
          resolve(receipt);
        } else {
          // Try again in 1 second
          window.setTimeout(function () {
            waitForReceipt(transactionHash);
          }, 1000);
        }
      }
    });
  });
}

},{"./resources.mjs":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CODE_HEX = exports.ABI = void 0;
var ABI = [{
  "type": "function",
  "name": "balanceOfAddress",
  "inputs": [{
    "name": "_address",
    "type": "address"
  }],
  "outputs": [{
    "name": "returnValue0",
    "type": "uint256"
  }],
  "constant": true,
  "payable": false
}, {
  "type": "function",
  "name": "holderBalance",
  "inputs": [],
  "outputs": [{
    "name": "returnValue0",
    "type": "uint256"
  }],
  "constant": true,
  "payable": false
}, {
  "type": "function",
  "name": "counterPartyBalance",
  "inputs": [],
  "outputs": [{
    "name": "returnValue0",
    "type": "uint256"
  }],
  "constant": true,
  "payable": false
}, {
  "type": "function",
  "name": "holderAddress",
  "inputs": [],
  "outputs": [{
    "name": "returnValue0",
    "type": "uint256"
  }],
  "constant": true,
  "payable": false
}, {
  "type": "function",
  "name": "counterPartyAddress",
  "inputs": [],
  "outputs": [{
    "name": "returnValue0",
    "type": "uint256"
  }],
  "constant": true,
  "payable": false
}, {
  "type": "function",
  "name": "transfer",
  "inputs": [{
    "name": "_from",
    "type": "address"
  }, {
    "name": "_to",
    "type": "address"
  }, {
    "name": "_amount",
    "type": "uint256"
  }],
  "outputs": [],
  "constant": false,
  "payable": false
}, {
  "type": "function",
  "name": "depositCollateral",
  "inputs": [{
    "name": "amount",
    "type": "uint256"
  }],
  "outputs": [],
  "constant": false,
  "payable": true
}, {
  "type": "event",
  "name": "TransferEvent",
  "inputs": [{
    "name": "result",
    "type": "int32",
    "indexed": false
  }]
}, {
  "type": "constructor",
  "inputs": [{
    "name": "holder_address",
    "type": "address"
  }, {
    "name": "counter_party_address",
    "type": "address"
  }]
}];
exports.ABI = ABI;
var CODE_HEX = '0x0061736d01000000013b0a60047f7f7f7f0060027f7f017f60017f017f60027f7f0060017f006000017f60000060057f7f7f7f7f0060057f7f7f7f7f017f60037f7f7f017f026b0703656e760576616c7565000403656e760c696e7075745f6c656e677468000503656e760b66657463685f696e707574000403656e760570616e6963000303656e760d73746f726167655f7772697465000303656e76066d656d6f72790201021003656e7603726574000303282703030307030300020306030606040406010300080401020001020804040400040304060103090604050170010a0a0608017f01418080040b0708010463616c6c002c090f010041010b091a1d1e1f23181b1c220af21d276d01037f230041206b22022400200241086a41106a22034100360200200241086a41086a2204420037030020024200370308200241086a41142001410c6a4114100c200041106a2003280200360000200041086a200429030037000020002002290308370000200241206a24000b7d01047f230041206b22022400200241186a22034200370300200241106a22044200370300200241086a22054200370300200242003703002002410c6a411420014114100c200041186a2003290300370000200041106a2004290300370000200041086a200529030037000020002002290300370000200241206a24000b100002402001450d0020002001100e0b0b39000240024020022001490d0020042002490d012000200220016b3602042000200320016a3602000f0b20012002100a000b20022004100b000b05001011000b05001011000b1900024020012003470d00200020022001102b1a0f0b1011000bb00101027f230041106b220124000240024002402000450d00200041036a4102762200417f6a220241ff014b0d01200241027441e884046a2202450d01200141e484043602042001200228020036020c200041012001410c6a200141046a41b08004101921002002200128020c3602000c020b410121000c010b200141002802e4840436020820004101200141086a41f8830441c8800410192100410020012802083602e484040b200141106a240020000bad0101017f230041106b2202240002402000450d00200220003602042001450d000240200141036a410276417f6a220041ff014b0d00200041027441e884046a2200450d00200241e484043602082002200028020036020c200241046a2002410c6a200241086a41b0800410242000200228020c3602000c010b200241002802e4840436020c200241046a2002410c6a41f8830441c8800410244100200228020c3602e484040b200241106a24000b090041e080041025000b040000000b05001015000b0500100f000be50101037f230041c0006b22012400200141186a4200370300200141106a4200370300200141086a42003703002001420037030020011000200141206a41186a4200370300200141206a41106a4200370300200141206a41086a420037030020014200370320411f2102200141206a2103024003402002417f460d012003200120026a2d00003a00002002417f6a2102200341016a21030c000b0b20002001290320370300200041186a200141206a41186a290300370300200041106a200141206a41106a290300370300200041086a200141206a41086a290300370300200141c0006a24000b5901037f024002400240024010012201450d002001417f4c0d022001100d2202450d0320021002200121030c010b41002103410121020b2000200336020420002002360200200020013602080f0b1012000b200141011010000b0900410041001003000b7002017f027e200041186a2100200141186a21024103210102400240024003402001417f460d01200141034b0d032000290300220320022903002204540d02200041786a2100200241786a21022001417f6a210120032004580d000b41010f0b41000f0b41ff010f0b200141041017000b05001011000b920101027f230041106b2204240020042001280200220128020036020c200241026a220220026c220241801020024180104b1b220541042004410c6a41f8830441988004101921022001200428020c360200024002402002450d00200242003702042002200220054102746a410272360200410021010c010b410121010b2000200236020420002001360200200441106a24000b6b01027f230041106b22052400024020002001200220032004102022060d00200541086a200320002001200428020c1100004100210620052802080d00200528020c220620022802003602082002200636020020002001200220032004102021060b200541106a240020060b02000b040020010b040041000b7201017f41002104024002404100200241027422022003410374418080016a220320032002491b418780046a2202411076400022034110742003417f461b2203450d00200342003702042003200320024180807c716a4102723602000c010b410121040b20002003360204200020043602000b05004180040b040041010bc90301067f2001417f6a2105410020016b21062000410274210720022802002108200441106a2109024002400240024003402008450d012008210102400340200141086a210420012802082208410171450d0120042008417e71360200024002402001280204417c712208450d004100200820082d00004101711b21080c010b410021080b20011021024020012d0000410271450d00200820082802004102723602000b20022008360200200821010c000b0b02402001280200417c71220a20046b2007490d0020042003200020092802001101004102746a41086a200a20076b20067122084d0d03200428020021082005200471450d040b200220083602000c000b0b41000f0b20084100360200200841786a2208420037020020082001280200417c71360200024020012802002202417c712204450d0020024102710d00200420042802044103712008723602040b20082008280204410371200172360204200141086a22042004280200417e7136020020012001280200220441037120087222023602002004410271450d0120012002417d71360200200820082802004102723602000c010b20022008417c71360200200121080b20082008280200410172360200200841086a0b8f0101027f0240024020002802002201417c712202450d0020014102710d00200220022802044103712000280204417c7172360204200041046a21020c010b200041046a21020b024020022802002202417c712201450d00200120012802004103712000280200417c7172360200200028020421020b200041046a2002410371360200200020002802004103713602000b02000b02000bb80101017f200028020022044100360200200441786a22002000280200417e71360200024020022003280214110200450d0002402004417c6a280200417c712202450d0020022d00004101710d0020001021024020002d0000410271450d00200220022802004102723602000b0f0b20002802002202417c712203450d0020024102710d0020032d00004101710d0020042003280208417c71360200200320004101723602080f0b20042001280200360200200120003602000b05001011000bb106010b7f230041d0016b22022400024002402001280208220341206a2204200128020422054d0d00200241f0006a41176a20024190016a41176a290000370000200241f0006a41106a20024190016a41106a290300370300200241f0006a41086a20024190016a41086a2903003703002002200229039001370370200241306a41176a200241d0006a41176a290000370000200241306a41106a200241d0006a41106a290300370300200241306a41086a200241d0006a41086a29030037030020022002290350370330200041033a0001410121010c010b200141086a2004360200200241086a20032004200128020020051009200228020c210320022802082105200241c8016a22044200370300200241b0016a41106a4200370300200241b0016a41086a4200370300200242003703b00141002101200241004120200520031009200241b0016a412020022802002002280204100c20024190016a41086a2203200241b0016a41096a220629000037030020024190016a41106a2205200241b0016a41116a220729000037030020024190016a41176a22082004290000370000200220022900b1013703900120022d00b0012109200241f0006a41176a220a2008290000370000200241f0006a41106a22082005290300370300200241f0006a41086a220b20032903003703002002200229039001370370200241d0006a41176a220c200a290000370000200241d0006a41106a220a2008290300370300200241d0006a41086a2208200b29030037030020022002290370370350200241306a41176a220b200c290000370000200241306a41106a220c200a290300370300200241306a41086a220a200829030037030020022002290350370330200241106a41176a2208200b290000370000200241106a41106a220b200c290300370300200241106a41086a220c200a290300370300200220022903303703102006200c2903003700002007200b29030037000020042008290000370000200220093a00b001200220022903103700b10120024190016a200241b0016a1006200041116a2005280000360000200041096a200329000037000020002002290090013700010b200020013a0000200241d0016a24000b05001011000bd20301057f230041b0016b22002400200041086a10142000280210210120002802082102200041d8006a1013200041f8006a41186a4200370300200041f8006a41106a4200370300200041f8006a41086a4200370300200042003703780240200041d8006a200041f8006a10290d002000200136021c2000200236021820004100360220200041f8006a200041186a1026200041286a200041f8006a102a200041f8006a200041186a1026200041c0006a200041f8006a102a200041d8006a41186a22014200370300200041d8006a41106a4200370300200041d8006a41086a42003703002000420037035820004198016a41106a2203200041286a41106a28020036020020004198016a41086a2204200041286a41086a2903003703002000200029032837039801200041f8006a20004198016a1007200041d8006a200041f8006a100420014200370000200041e9006a4200370000200041e1006a420037000020004200370059200041013a00582003200041c0006a41106a2802003602002004200041c0006a41086a2903003703002000200029034037039801200041f8006a20004198016a1007200041d8006a200041f8006a10042002200028020c1008200041b0016a24000f0b41c081041025000b0f0020002001101641ff01714101460b4b01017f200141016a2102024020012d00004101460d0020002002290000370000200041106a200241106a280000360000200041086a200241086a2900003700000f0b20022d00001027000b3001017f410021030240034020022003460d01200020036a200120036a2d00003a0000200341016a21030c000b0b20000b0e00102841ec8c0441cadd0010050b0bd16a0400418080040bd801d800010020000000f800010062000000d3070000090000000100000000000000010000000200000003000000040000000500000004000000040000000600000007000000080000000900000000000000010000000200000003000000040000005a010100110000006b01010013000000f5020000050000007e0101001d0000009b0101005d000000290000000200000050020100120000002e0201000a000000270000000200000038020100180000002e0201000a0000002700000002000000f8010100360000002e0201000a00000027000000020000000041d881040b8a03617373657274696f6e206661696c65643a2038203c3d206275662e6c656e28292f55736572732f6e6f61682d76696e63656e7a6e6f65682f2e636172676f2f72656769737472792f7372632f6769746875622e636f6d2d316563633632393964623965633832332f627974656f726465722d312e332e302f7372632f6c69622e72736361706163697479206f766572666c6f776c6962616c6c6f632f7261775f7665632e727361726974686d65746963206f7065726174696f6e206f766572666c6f772f55736572732f6e6f61682d76696e63656e7a6e6f65682f2e636172676f2f72656769737472792f7372632f6769746875622e636f6d2d316563633632393964623965633832332f75696e742d302e352e302f7372632f6c69622e7273556e61626c6520746f206163636570742076616c756520696e206e6f6e2d70617961626c6520636f6e7374727563746f722063616c6c7372632f6c69622e7273496e76616c6964206d6574686f64207369676e6174757265496e76616c69642061626920696e766f6b650041e484040b840800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041ec8c040bca5d0061736d0100000001410b60047f7f7f7f0060027f7f017f60017f017f60027f7f0060017f006000017f60000060037f7f7f0060057f7f7f7f7f0060057f7f7f7f7f017f60037f7f7f017f0296010a03656e7604656c6f67000003656e760c73746f726167655f72656164000303656e760576616c7565000403656e760c696e7075745f6c656e677468000503656e760b66657463685f696e707574000403656e7603726574000303656e760570616e6963000303656e760d73746f726167655f7772697465000303656e760673656e646572000403656e76066d656d6f727902010210033b3a03030303030303040407030308030303000203060306080604040306010300090401020001020904040400040303030303070401030607030a0a04050170010a0a0608017f01418080040b0708010463616c6c003e090f010041010b09292c2d2e32272a2b310af84d3a6801017f230041c0006b2202240020022001100a200241206a41186a200241186a290000370300200241206a41106a200241106a290000370300200241206a41086a200241086a290000370300200220022900003703202000200241206a100b200241c0006a24000b7601047f230041206b22022400200241186a22034200370300200241106a22044200370300200241086a2205420037030020024200370300200120021001200041186a2003290300370000200041106a2004290300370000200041086a200529030037000020002002290300370000200241206a24000b6d01037f230041206b22022400200241086a41106a22034100360200200241086a41086a2204420037030020024200370308200241086a41142001410c6a41141019200041106a2003280200360000200041086a200429030037000020002002290308370000200241206a24000b2e01017f230041c0006b22022400200241206a2001100d2002200241206a100a20002002100e200241c0006a24000b9c0101017f230041c0006b22022400200241286a41106a200141106a280000360200200241286a41086a200141086a29000037030020022001290000370328200241086a200241286a100f200041086a200241086a41086a290300370000200041106a200241086a41106a290300370000200041186a200241086a41186a290300370000200241013a000820002002290308370000200241c0006a24000bea0101027f230041c0006b220241186a200141186a290000370300200241106a200141106a290000370300200241086a200141086a29000037030020022001290000370300200241206a41186a4200370300200241206a41106a4200370300200241206a41086a420037030020024200370320411f2101200241206a2103024003402001417f460d012003200220016a2d00003a00002001417f6a2101200341016a21030c000b0b20002002290320370300200041186a200241206a41186a290300370300200041106a200241206a41106a290300370300200041086a200241206a41086a2903003703000b7d01047f230041206b22022400200241186a22034200370300200241106a22044200370300200241086a22054200370300200242003703002002410c6a4114200141141019200041186a2003290300370000200041106a2004290300370000200041086a200529030037000020002002290300370000200241206a24000bfc0201027f230041f0006b22012400200142c9a4daeba08286d2ca00370300200142cd88b78e9a9fb7e47337030820014190b4013b0110200142f79c90e3c7e5d7a87e370112200141b4cbf14436011a200141f91d3b011e200141206a1011200141206a41047221020240024020004100480d00200141e8006a4100360200200141e0006a4200370300200141d8006a4200370300200142003703500c010b200141e8006a417f360200200141e0006a427f370300200141d8006a427f3703002001427f3703500b200120003a006f200120004110763a006d200120004118763a006c200120004108763a006e2002200141d0006a200141f0006a1012200141d0006a41186a200141206a41186a280200360200200141d0006a41106a200141206a41106a290300370300200141d0006a41086a200141206a41086a29030037030020012001290320370350200141c0006a200141d0006a1013200141012001280240220020012802481000200020012802441014200141f0006a24000b4101017f02404120101a2201450d00200020013602042000412036020020004201370210200041086a4220370200200041186a41003602000f0b41204101101d000b2e01017f2000200220016b2202101820002000280208220320026a360208200320002802006a20022001200210190b830101047f230041106b2202240002402001410c6a22032802002001280200470d00200241086a2204200328020036020020022001290204370300200141146a28020021052002200128021022032003200141186a2802006a1012200041086a200428020036020020002002290300370200200320051014200241106a24000f0b101e000b100002402001450d0020002001101b0b0b39000240024020022001490d0020042002490d012000200220016b3602042000200320016a3602000f0b200120021016000b200220041017000b0500101e000b0500101e000b9c0101037f02400240024020002802042202200028020822036b20014f0d00200320016a22012003490d0120024101742203200120012003491b22014100480d01024002402002450d00200028020021042001101a2203450d042003200420012002200220014b1b10411a20042002101b0c010b2001101a2203450d030b20002003360200200041046a20013602000b0f0b101c000b20014101101d000b1900024020012003470d0020002002200110411a0f0b101e000bb00101027f230041106b220124000240024002402000450d00200041036a4102762200417f6a220241ff014b0d01200241027441e884046a2202450d01200141e484043602042001200228020036020c200041012001410c6a200141046a41b08004102821002002200128020c3602000c020b410121000c010b200141002802e4840436020820004101200141086a41f8830441c8800410282100410020012802083602e484040b200141106a240020000bad0101017f230041106b2202240002402000450d00200220003602042001450d000240200141036a410276417f6a220041ff014b0d00200041027441e884046a2200450d00200241e484043602082002200028020036020c200241046a2002410c6a200241086a41b0800410332000200228020c3602000c010b200241002802e4840436020c200241046a2002410c6a41f8830441c8800410334100200228020c3602e484040b200241106a24000b090041e080041034000b040000000b05001024000b39000240024020022001490d0020042002490d012000200220016b3602042000200320016a3602000f0b200120021016000b200220041017000b0500101c000be50101037f230041c0006b22012400200141186a4200370300200141106a4200370300200141086a42003703002001420037030020011002200141206a41186a4200370300200141206a41106a4200370300200141206a41086a420037030020014200370320411f2102200141206a2103024003402002417f460d012003200120026a2d00003a00002002417f6a2102200341016a21030c000b0b20002001290320370300200041186a200141206a41186a290300370300200041106a200141206a41106a290300370300200041086a200141206a41086a290300370300200141c0006a24000b5901037f024002400240024010032201450d002001417f4c0d022001101a2202450d0320021004200121030c010b41002103410121020b2000200336020420002002360200200020013602080f0b1020000b20014101101d000b0900200020011005000b0900410041001006000b7002017f027e200041186a2100200141186a21024103210102400240024003402001417f460d01200141034b0d032000290300220320022903002204540d02200041786a2100200241786a21022001417f6a210120032004580d000b41010f0b41000f0b41ff010f0b200141041026000b0500101e000b920101027f230041106b2204240020042001280200220128020036020c200241026a220220026c220241801020024180104b1b220541042004410c6a41f8830441988004102821022001200428020c360200024002402002450d00200242003702042002200220054102746a410272360200410021010c010b410121010b2000200236020420002001360200200441106a24000b6b01027f230041106b22052400024020002001200220032004102f22060d00200541086a200320002001200428020c1100004100210620052802080d00200528020c220620022802003602082002200636020020002001200220032004102f21060b200541106a240020060b02000b040020010b040041000b7201017f41002104024002404100200241027422022003410374418080016a220320032002491b418780046a2202411076400022034110742003417f461b2203450d00200342003702042003200320024180807c716a4102723602000c010b410121040b20002003360204200020043602000b05004180040b040041010bc90301067f2001417f6a2105410020016b21062000410274210720022802002108200441106a2109024002400240024003402008450d012008210102400340200141086a210420012802082208410171450d0120042008417e71360200024002402001280204417c712208450d004100200820082d00004101711b21080c010b410021080b20011030024020012d0000410271450d00200820082802004102723602000b20022008360200200821010c000b0b02402001280200417c71220a20046b2007490d0020042003200020092802001101004102746a41086a200a20076b20067122084d0d03200428020021082005200471450d040b200220083602000c000b0b41000f0b20084100360200200841786a2208420037020020082001280200417c71360200024020012802002202417c712204450d0020024102710d00200420042802044103712008723602040b20082008280204410371200172360204200141086a22042004280200417e7136020020012001280200220441037120087222023602002004410271450d0120012002417d71360200200820082802004102723602000c010b20022008417c71360200200121080b20082008280200410172360200200841086a0b8f0101027f0240024020002802002201417c712202450d0020014102710d00200220022802044103712000280204417c7172360204200041046a21020c010b200041046a21020b024020022802002202417c712201450d00200120012802004103712000280200417c7172360200200028020421020b200041046a2002410371360200200020002802004103713602000b02000b02000bb80101017f200028020022044100360200200441786a22002000280200417e71360200024020022003280214110200450d0002402004417c6a280200417c712202450d0020022d00004101710d0020001030024020002d0000410271450d00200220022802004102723602000b0f0b20002802002202417c712203450d0020024102710d0020032d00004101710d0020042003280208417c71360200200320004101723602080f0b20042001280200360200200120003602000b0500101e000bc50201037f230041c0006b220224000240024002402001280208220341206a220420012802044d0d0020004181063b01000c010b200141086a2004360200200341604f0d0120012802002101200241386a4200370300200241306a4200370300200241206a41086a420037030020024200370320200120036a2104411f2101200241206a2103024003402001417f460d012003200420016a2d00003a00002001417f6a2101200341016a21030c000b0b200241186a2201200241206a41186a290300370300200241106a2203200241206a41106a290300370300200241086a2204200241206a41086a29030037030020022002290320370300200041003a0000200041206a2001290300370300200041186a2003290300370300200041106a2004290300370300200041086a20022903003703000b200241c0006a24000f0b200320041016000bb106010b7f230041d0016b22022400024002402001280208220341206a2204200128020422054d0d00200241f0006a41176a20024190016a41176a290000370000200241f0006a41106a20024190016a41106a290300370300200241f0006a41086a20024190016a41086a2903003703002002200229039001370370200241306a41176a200241d0006a41176a290000370000200241306a41106a200241d0006a41106a290300370300200241306a41086a200241d0006a41086a29030037030020022002290350370330200041033a0001410121010c010b200141086a2004360200200241086a20032004200128020020051015200228020c210320022802082105200241c8016a22044200370300200241b0016a41106a4200370300200241b0016a41086a4200370300200242003703b00141002101200241004120200520031015200241b0016a412020022802002002280204101920024190016a41086a2203200241b0016a41096a220629000037030020024190016a41106a2205200241b0016a41116a220729000037030020024190016a41176a22082004290000370000200220022900b1013703900120022d00b0012109200241f0006a41176a220a2008290000370000200241f0006a41106a22082005290300370300200241f0006a41086a220b20032903003703002002200229039001370370200241d0006a41176a220c200a290000370000200241d0006a41106a220a2008290300370300200241d0006a41086a2208200b29030037030020022002290370370350200241306a41176a220b200c290000370000200241306a41106a220c200a290300370300200241306a41086a220a200829030037030020022002290350370330200241106a41176a2208200b290000370000200241106a41106a220b200c290300370300200241106a41086a220c200a290300370300200220022903303703102006200c2903003700002007200b29030037000020042008290000370000200220093a00b001200220022903103700b10120024190016a200241b0016a100b200041116a2005280000360000200041096a200329000037000020002002290090013700010b200020013a0000200241d0016a24000b880402077f017e230041306b22022400200241106a41186a200141186a290300370300200241106a41106a200141106a290300370300200241106a41086a200141086a290300370300200220012903003703102000410c6a2201280200220341206a210402400240200341604f0d00200041046a2205412010182005280200200128020022066a21074100210102400340200720016a2105200141016a2208411f4b0d01200541003a0000200821010c000b0b200541003a0000200620016a41016a21010c010b4100210102400340200320016a41206a220520034f0d01200541016a2005490d01200141016a21010c000b0b200320016b21010b2000410c6a2001360200200241086a20032004200041046a2802002001101f200241286a210541002108200228020c21072002280208210041032103410021010240024002400340200141034b0d0120022008200720002007101f200341034b0d02200228020441074d0d03200141016a2101200228020020052903002209423886200942288642808080808080c0ff0083842009421886428080808080e03f8320094208864280808080f01f838484200942088842808080f80f832009421888428080fc07838420094228884280fe03832009423888848484370000200841086a2108200541786a21052003417f6a21030c000b0b200241306a24000f0b200341041026000b418080041034000b9f0101017f230041c0006b22022400200241186a200141186a290000370300200241106a200141106a290000370300200241086a200141086a29000037030020022001290000370300200241206a41186a4200370300200241206a41106a4200370300200241206a41086a420037030020024200370320200241206a4120200241201019200041046a200241206a200241206a41206a1012200241c0006a24000bf80202047f017e230041c0006b22022400200241186a2203200141186a290300370300200241106a200141106a290300370300200241086a200141086a29030037030020022001290300370300200241206a41186a4200370300200241206a41106a4200370300200241206a41086a42003703002002420037032041002101200241206a210441032105024002400340200141034b0d01200541034b0d02200420032903002206423886200642288642808080808080c0ff0083842006421886428080808080e03f8320064208864280808080f01f838484200642088842808080f80f832006421888428080fc07838420064228884280fe03832006423888848484370000200441086a21042005417f6a2105200341786a2103200141016a21010c000b0b20002002290320370000200041186a200241206a41186a290300370000200041106a200241206a41106a290300370000200041086a200241206a41086a290300370000200241c0006a24000f0b417f41041026000bec0103027e017f057e2001290308220320022903087c2204200354210520022903182106200229031021072001290318210320012903102108024002402001290300220920022903007c220a20095a0d00200442017c220920045420056a21050c010b200421090b200820077c22042008542101024002402005450d0020042005ad7c220720045420016a21010c010b200421070b200320067c220820035421020240024002402001450d0020082001ad7c220320085420026a0d010c020b200821032002450d010b41f880041034000b200020093703082000200a37030020002007370310200020033703180b0500101e000b0f0020002001102541ff01714101460b4b01017f200141016a2102024020012d00004101460d0020002002290000370000200041106a200241106a280000360000200041086a200241086a2900003700000f0b20022d0000103b000b2f01017f230041206b22002400200041106a1022200020002802102000280218103f200028020020002802081023000bcf1903047f077e017f230041d0026b22032400024002400240024002400240024002400240200241034d0d00024002400240024002400240024002400240200128000022044118742004410874418080fc07717220044108764180fe037120044118767272220441c8f8add902460d000240200441e0d7f0b779460d002004418ca5c9997b460d022002417c6a2102200141046a21010240024002402004419fc0d2d67b460d00200441c8d9aef57b460d01200441b6b6c2e07c460d022004418fd784b178470d0e200341b0026a1021200341e8006a41186a22044200370300200341e8006a41106a22054200370300200341e8006a41086a2206420037030020034200370368200341b0026a200341e8006a103c0d0f200320023602f401200320013602f001200341003602f801200341e8006a200341f0016a103620034190026a200341e8006a103d200341e8006a20034190026a100d200341d0016a200341e8006a100a200341b0026a200341d0016a100e20034190026a10112004200341b0026a41186a2903003703002005200341b0026a41106a2903003703002006200341b0026a41086a290300370300200320032903b00237036820034190026a200341e8006a1037200420034190026a41186a280200360200200520034190026a41106a290300370300200620034190026a41086a29030037030020032003290390023703682000200341e8006a10130c0c0b2003200236024c2003200136024820034100360250200341e8006a200341c8006a1035200341b0016a200341e8006a1040200341e8006a41106a22044100360200200341e8006a41086a2201420037030020034200370368200341e8006a100820034190016a41106a200428020036020020034190016a41086a20012903003703002003200329036837039001200341f0016a20034190016a100c200341b0026a41186a200341f0016a41186a290300370300200341b0026a41106a200341f0016a41106a290300370300200341b0026a41086a200341f0016a41086a290300370300200320032903f0013703b002200341e8006a41186a2202200341b0016a41186a2903003703002004200341b0016a41106a2903003703002001200341b0016a41086a290300370300200320032903b00137036820034190026a200341b0026a200341e8006a103a200341b0026a20034190016a100d200220034190026a41186a290300370300200420034190026a41106a290300370300200120034190026a41086a2903003703002003200329039002370368200341d0016a200341e8006a1039200341b0026a200341d0016a100720004100360208200042013702000c0b0b200341b0026a102120034180016a4200370300200341f8006a4200370300200341f0006a420037030020034200370368200341b0026a200341e8006a103c0d0e2003200236020c2003200136020820034100360210200341e8006a200341086a1036200341186a200341e8006a103d200341e8006a200341086a1036200341306a200341e8006a103d200341e8006a200341086a1035200341c8006a200341e8006a104020034190016a200341186a100c200341b0016a200341306a100c20034190016a200341c8006a102541ff017141ff01460d04200341306a200341186a41141042450d0520034180016a4200370300200341f8006a4200370300200341f0006a420037030020034200370368200341c8006a200341e8006a41201042450d06200329039801220720032903507d22082007562101200329036021092003290358210a20032903a801210720032903a001210b200329039001220c20032903487d220d200c580d072008427f7c220c20085620016a21010c080b200341b0026a1021200341e8006a41186a22044200370300200341e8006a41106a22014200370300200341e8006a41086a2202420037030020034200370368200341b0026a200341e8006a103c0d0e2004420037030020014200370300200242003703002003420037036820034190026a200341e8006a1009200341b0026a20034190026a100c20034190026a10112004200341b0026a41186a2903003703002001200341b0026a41106a2903003703002002200341b0026a41086a290300370300200320032903b00237036820034190026a200341e8006a1037200420034190026a41186a280200360200200120034190026a41106a290300370300200220034190026a41086a29030037030020032003290390023703682000200341e8006a10130c090b200341b0026a1021200341e8006a41186a22044200370300200341e8006a41106a22014200370300200341e8006a41086a2202420037030020034200370368200341b0026a200341e8006a103c0d0e20044200370300200142003703002002420037030020034200370368200341d0016a200341e8006a100a200341b0026a41186a2205200341d0016a41186a290000370300200341b0026a41106a2206200341d0016a41106a290000370300200341b0026a41086a220e200341d0016a41086a290000370300200320032900d0013703b00220034190026a101120042005290300370300200120062903003703002002200e290300370300200320032903b00237036820034190026a200341e8006a1038200420034190026a41186a280200360200200120034190026a41106a290300370300200220034190026a41086a29030037030020032003290390023703682000200341e8006a10130c080b200341b0026a1021200341e8006a41186a4200370300200341e8006a41106a22044200370300200341e8006a41086a420037030020034200370368200341b0026a200341e8006a103c0d0e200341e8006a41186a22014200370000200341f9006a4200370000200341f1006a420037000020034200370069200341013a0068200341d0016a200341e8006a100a200341b0026a41186a2202200341d0016a41186a290000370300200341b0026a41106a2205200341d0016a41106a290000370300200341b0026a41086a2206200341d0016a41086a290000370300200320032900d0013703b00220034190026a10112001200229030037030020042005290300370300200341e8006a41086a22022006290300370300200320032903b00237036820034190026a200341e8006a1038200120034190026a41186a280200360200200420034190026a41106a290300370300200220034190026a41086a29030037030020032003290390023703682000200341e8006a10130c070b200341b0026a1021200341e8006a41186a22044200370300200341e8006a41106a22014200370300200341e8006a41086a2202420037030020034200370368200341b0026a200341e8006a103c0d0e20044200370000200341f9006a4200370000200341f1006a420037000020034200370069200341013a006820034190026a200341e8006a1009200341b0026a20034190026a100c20034190026a10112004200341b0026a41186a2903003703002001200341b0026a41106a2903003703002002200341b0026a41086a290300370300200320032903b00237036820034190026a200341e8006a1037200420034190026a41186a280200360200200120034190026a41106a290300370300200220034190026a41086a29030037030020032003290390023703682000200341e8006a10130c060b410010100c040b410110100c030b410210100c020b2008210c0b200b200a7d2208200b562104024002402001450d0020082001ad7d220a20085620046a21040c010b2008210a0b200720097d220b2007562101024002402004450d00200b2004ad7d2207200b5620016a450d010c0c0b200b210720010d0b0b200341b0026a41186a200341b0016a41186a290300370300200341b0026a41106a200341b0016a41106a290300370300200341b0026a41086a200341b0016a41086a290300370300200320032903b0013703b002200341e8006a41186a2204200341c8006a41186a290300370300200341e8006a41106a2201200341c8006a41106a290300370300200341e8006a41086a2202200341c8006a41086a29030037030020032003290348370368200341f0016a200341b0026a200341e8006a103a20034190026a200341186a100d2003200c3703702003200d3703682003200a3703782003200737038001200341b0026a200341e8006a103920034190026a200341b0026a1007200341b0026a200341306a100d2004200341f0016a41186a2903003703002001200341f0016a41106a2903003703002002200341f0016a41086a290300370300200320032903f001370368200341d0016a200341e8006a1039200341b0026a200341d0016a1007410210100b20004100360208200042013702000b200341d0026a24000f0b419081041034000b41a881041034000b41c081041034000b41c081041034000b41c081041034000b41c081041034000b41c081041034000b41c081041034000b41f880041034000b5500024020012d00004101460d00200041186a200141206a290300370300200041106a200141186a290300370300200041086a200141106a2903003703002000200141086a2903003703000f0b20012d0001103b000b3001017f410021030240034020022003460d01200020036a200120036a2d00003a0000200341016a21030c000b0b20000b4801047f410021034100210402400340200420024f0d01200120046a2105200020046a2106200441016a210420062d0000220620052d00002205460d000b200620056b21030b20030b0bff0c0300418080040bd801d800010020000000f800010062000000d3070000090000000100000000000000010000000200000003000000040000000500000004000000040000000600000007000000080000000900000000000000010000000200000003000000040000005a010100110000006b01010013000000f5020000050000007e0101001d0000009b0101005d000000290000000200000050020100120000002e0201000a000000270000000200000038020100180000002e0201000a0000002700000002000000f8010100360000002e0201000a00000027000000020000000041d881040b8a03617373657274696f6e206661696c65643a2038203c3d206275662e6c656e28292f55736572732f6e6f61682d76696e63656e7a6e6f65682f2e636172676f2f72656769737472792f7372632f6769746875622e636f6d2d316563633632393964623965633832332f627974656f726465722d312e332e302f7372632f6c69622e72736361706163697479206f766572666c6f776c6962616c6c6f632f7261775f7665632e727361726974686d65746963206f7065726174696f6e206f766572666c6f772f55736572732f6e6f61682d76696e63656e7a6e6f65682f2e636172676f2f72656769737472792f7372632f6769746875622e636f6d2d316563633632393964623965633832332f75696e742d302e352e302f7372632f6c69622e7273556e61626c6520746f206163636570742076616c756520696e206e6f6e2d70617961626c6520636f6e7374727563746f722063616c6c7372632f6c69622e7273496e76616c6964206d6574686f64207369676e6174757265496e76616c69642061626920696e766f6b650041e484040b84080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
exports.CODE_HEX = CODE_HEX;

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.occurrences = occurrences;
exports.isNumeric = isNumeric;

/**
 * @author Noah-Vincenz Noeh <noah-vincenz.noeh18@imperial.ac.uk>
 */

/* jshint esversion: 6 */

/**
 * Used to add a sleep() break to JavaScript code execution.
 */
function sleep(ms) {
  var start = new Date().getTime();

  for (var i = 0; i < 1e7; i++) {
    if (new Date().getTime() - start > ms) {
      break;
    }
  }
}
/*
* @author Vitim.us https://gist.github.com/victornpb/7736865
* @see http://stackoverflow.com/questions/4009756/how-to-count-string-occurrence-in-string/7924240#7924240
*/


function occurrences(string, subString, allowOverlapping) {
  string += "";
  subString += "";
  if (subString.length <= 0) return string.length + 1;
  var n = 0,
      pos = 0,
      step = allowOverlapping ? 1 : subString.length;

  while (true) {
    pos = string.indexOf(subString, pos);

    if (pos >= 0) {
      ++n;
      pos += step;
    } else break;
  }

  return n;
}
/**
 * Checks whether a given string is a number.
 * @param {string} num - The string to be checked.
 * @returns {boolean} The boolean value specifying whether the given string is a number.
 */


function isNumeric(num) {
  return !isNaN(num);
}
/**
 * Useful debugging function for printing stacks.
 * @param {array} stack - The stack to be printed.
 * @param {string} name - The name given to the stack.
 */


function printStack(stack, name) {
  console.log(name + ": " + stack.length);
  var x;

  for (var x = 0; x < stack.length; ++x) {
    console.log(name + " - " + x + ": " + stack[x]);
  }
}

},{}],5:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nonExistingTerm = nonExistingTerm;
exports.replaceUserDefinitions = replaceUserDefinitions;
exports.cleanUpBeforeDecomp = cleanUpBeforeDecomp;
exports.extractAllSubHorizons = extractAllSubHorizons;
exports.evaluateConditionals = evaluateConditionals;
exports.evaluate = evaluate;
exports.getHorizon = getHorizon;
exports.decompose = decompose;
exports.getValue = getValue;
exports.decomposeAnds = decomposeAnds;

var _stringmanipulation = require("./stringmanipulation.mjs");

var _contract = require("./contract.mjs");

var _deploy = require("./deploy/deploy.mjs");

var _oracles = require("./oracles.mjs");

var _generalfunctions = require("./generalfunctions.mjs");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var numberOfSubContracts = 0,
    numberOfContracts = 0,
    superContractsMap = new Map(),
    // map from superContract id to set of contract objects contained within super contract
agreedOracleAddress,
    account1Deposited = false,
    account2Deposited = false,
    definitionsMap = new Map(),
    observablesArr = ["libor3m", "tempInLondon"],
    uniqueID = 0,
    // id to keep track of divs for contract choices (and remove these)
acquireBtnToBeDisabled1 = true,
    acquireBtnToBeDisabled2 = true,
    contractsBeingDecomposed = 1,
    stringToAddToBeginning = "",
    stringToAddToEnd = "";
/**
 * This is called when the web page is loaded and is used for initialising UI elements as well as initialising other important system components.
 */

window.addEventListener('load', function () {
  // commented for testing purposes

  /**/
  document.getElementById("deposit_button1").disabled = true;
  document.getElementById("deposit_button2").disabled = true;
  document.getElementById("make_transaction_button").disabled = true;
  document.getElementById("select_deposit").disabled = true;
  document.getElementById("transaction_input_textarea").disabled = true;
  /**/

  addDepositSelectOptions();
  (0, _oracles.createOracles)(); // start timer

  update();
  runTimer(); //testPerformance();
});
/**
 * Tests the runtime taken to execute the evaluateConditionals or processContract function
 */

function testPerformance() {} // evaluateConditionals -- "if ( one [>] zero ) { zero } else { one }" then replace one in condition by entire contract

/*
var firstPart = "if ( ";
var secondPart = " [>] zero ) { zero } else { one }";
var tobeadded = "if ( one [>] zero ) { zero } else { one }";
runPerformanceTests(i, tobeadded);
for (var i = 1; i < 200; ++i) {
    var newtest = firstPart + tobeadded + secondPart;
    runPerformanceTests(i, newtest);
    firstPart = firstPart + "if ( ";
    secondPart = secondPart + " [>] zero ) { zero } else { one }";
}
*/
// processContract without evaluateConditionals need -- "zero or one" then replace one by scaleK 5 ( zero and one )

/*
var firstPart = "zero or ";
var secondPart = "one"
var tobeadded = "scaleK 5 ( zero or ";
for (var i = 0; i < 200; ++i) {
    var newtest = firstPart + secondPart;
    runPerformanceTests(i, newtest);
    firstPart += tobeadded;
    secondPart += " )";
}
*/

/**
 * Used to test the performance of the evaluateConditionals or processContract function.
 * @param {number} index - The index passed in from the loop inside the testPerformance function.
 * @param {string} contractString - The contract string used as input.
 */


function runPerformanceTests(index, contractString) {
  console.log(""); //console.log(contractString);

  console.log(index + "-nested");
  var sum = 0;

  for (var i = 0; i < 10; ++i) {
    var t0 = performance.now(); //evaluateConditionals(contractString);

    processContract(contractString, true, false, 0);
    var t1 = performance.now();
    sum += t1 - t0;
  }

  console.log((sum / 10).toFixed(2) + " milliseconds.");
  console.log("");
}
/**
 * This adds elements to the select item in our UI.
 */


function addDepositSelectOptions() {
  var $select = $(".custom_select");

  for (var i = 1; i <= 100; ++i) {
    $select.append($('<option></option>').val(i).html(i));
  }
}
/**
 * This is called when the user presses the button to add a custom-defined definition in the UI.
 * @param {string} inputString - The input string specifying the definition to be added.
 */


global.addDefinition = function (inputString) {
  try {
    document.getElementById("add_definitions_status").innerHTML = ""; // remove multiple whitespaces

    inputString = inputString.replace(/  +/gm, " "); // pattern matching for semantics

    var matches = inputString.match(/^.+\s?=\s?.+;$/);

    if (inputString === "" || matches === null) {
      document.getElementById("add_definitions_status").innerHTML = "Please provide a valid definition.";
      throw new Error("Please provide a valid definition.");
    }

    document.getElementById("input_added_textarea").innerHTML = "";
    var strArr = inputString.split("="),
        part1 = (0, _stringmanipulation.rTrimWhiteSpace)(strArr[0]),
        part2 = (0, _stringmanipulation.trimSemiColon)((0, _stringmanipulation.lTrimWhiteSpace)(strArr[1])),
        part1Arr = part1.split(" "),
        part2Arr = part2.split(" "); // check semantics of second part

    for (var i = 0; i < part2Arr.length; ++i) {
      var term = part2Arr[i];

      if (!part1.includes(term) && nonExistingTerm(term) && !definitionsMap.has(term)) {
        document.getElementById("add_definitions_status").innerHTML = "Please provide a valid definition.";
        throw new Error("Please provide a valid definition.");
      }
    } // or just use first word - add checking and then tell user that first term must be definition
    // need to find word in lhs string thats not in rhs and not one of the existing terms & add definition to map


    for (var i = 0; i < part1Arr.length; ++i) {
      var term = part1Arr[i];

      if (!part2.includes(term) && nonExistingTerm(term)) {
        definitionsMap.set(term, part1 + "=" + part2);
      }
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = definitionsMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2),
            key = _step$value[0],
            value = _step$value[1];

        // need to do this in order to allow overwriting of definitions
        var valueArr = value.split("=");
        document.getElementById("input_added_textarea").innerHTML += key + ": " + valueArr[0] + " = " + valueArr[1] + "\n";
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } catch (e) {
    console.log("Invalid definition provided.");
    return;
  }
};
/**
 * This checks if the given term is not part of our language.
 * @param {string} term - The term to be checked.
 * @returns {boolean} Boolean specifying whether the given term is part of our language.
 */


function nonExistingTerm(term) {
  if (term !== "give" && term !== "truncate" && term !== "get" && term !== "one" && term !== "zero" && term !== "scaleK" && term !== "one" && !COMPARISONOPERATOR(term) && term !== "&&" && term !== "if" && term !== "||" && !(0, _generalfunctions.isNumeric)(term) && term !== "(" && term !== ")" && !(0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(term))) && term !== "else" && term !== "}" && term !== "{" && term !== "and" && term !== "or" && !observablesArr.includes(term)) {
    return true;
  }

  return false;
}
/**
 * This is called when processing a contract in order to replace any contained custom-defined user definitions.
 * @param {string} inputString - The contract string to be checked for custom-defined definitions.
 * @param {map} mapOfDefinitions - The map to be checked for custom-defined definitions.
 * @returns {string} The modified input string.
 */


function replaceUserDefinitions(inputString, mapOfDefinitions) {
  var strSplit = inputString.split(" "),
      keys = Array.from(mapOfDefinitions.keys()),
      intersection = strSplit.filter(function (value) {
    return keys.includes(value);
  }); // check if any definition appears in inputString

  while (intersection.length !== 0) {
    for (var i = 0; i < intersection.length; ++i) {
      // check for if any definition appears in inputString
      var regex = new RegExp("(.*)(" + intersection[i] + ")(.*)"),
          matchObj1 = regex.exec(inputString),
          // find matching part in string
      value = mapOfDefinitions.get(intersection[i]),
          valueArr = value.split("="),
          lhs = valueArr[0],
          newValue = valueArr[1],
          endPartArr = (0, _stringmanipulation.lTrimWhiteSpace)(matchObj1[2] + matchObj1[3]).split(" "),
          lhsArr = lhs.split(" "); // do not need to trim by whitespace here as we add no whitespace when adding definitions

      for (var j = 1; j < lhsArr.length; ++j) {
        // skipping first index as this is definition
        regex = new RegExp("(.+\\s)?(" + lhsArr[j] + ")(\\s.+)?");
        var matchObj2 = regex.exec(newValue);
        newValue = matchObj2[1] + endPartArr[j] + matchObj2[3];
      }

      endPartArr.splice(0, lhsArr.length);

      if (newValue.indexOf("one") !== newValue.lastIndexOf("one") || newValue.indexOf("zero") !== newValue.lastIndexOf("zero") || newValue.includes("one") && newValue.includes("zero")) {
        // value consists of multiple contracts - add parenthesis
        inputString = endPartArr.length > 0 ? matchObj1[1] + " ( " + newValue + " ) " + endPartArr.join(" ") : matchObj1[1] + " ( " + newValue + ")";
      } else {
        // need to add the whitespace as we trimmed it previously
        inputString = endPartArr.length > 0 ? matchObj1[1] + newValue + " " + endPartArr.join(" ") : matchObj1[1] + newValue;
      }
    }

    strSplit = inputString.split(" ");
    intersection = strSplit.filter(function (value) {
      return keys.includes(value);
    });
  }

  return inputString;
}
/**
 * This is called to check whether a given contract is well-formed.
 * @param {string} inputString - The contract string to be checked.
 * @returns {boolean} The boolean value specifying whether the given contract is correct.
 */


function correctConstruct(inputString) {
  if (inputString === "") {
    document.getElementById("transaction_status").innerHTML = "Please provide some contract input.";
    return false;
  }

  if ((0, _stringmanipulation.openingParensAmount)(inputString) !== (0, _stringmanipulation.closingParensAmount)(inputString)) {
    document.getElementById("transaction_status").innerHTML = "The contract is not constructed properly. Parenthesis mismatch.";
    return false;
  }

  if (!inputString.includes("one") && !inputString.includes("zero")) {
    document.getElementById("transaction_status").innerHTML = "The contract is not constructed properly. A contract must include either 'one' or 'zero'.";
    return false;
  }

  if (inputString.includes("get") && !inputString.includes("truncate")) {
    document.getElementById("transaction_status").innerHTML = "The contract is not constructed properly. A contract cannot contain 'get' without 'truncate'.";
    return false;
  }

  return true;
}
/**
 * This is called to obtain a subcontract string from a given array.
 * @param {array} array - The array to be iterated through.
 * @param {number} indexToStartFrom - The index from which iterations should begin.
 * @returns {array} A pair containing the extracted subcontract string as well as its length.
 */


function obtainSubContractString(array, indexToStartFrom) {
  // returns subcontractString and the number of items in the string
  var stringToReturn = "";

  if (array[indexToStartFrom] === "(") {
    var openingParens = 1;

    for (var i = indexToStartFrom + 1; i < array.length; ++i) {
      // if string starts with opening paren wait until get balanced closing paren
      var term = array[i];
      stringToReturn = stringToReturn === "" ? term : stringToReturn + " " + term;

      if (term === "(") {
        ++openingParens;
      } else if (term === ")") {
        --openingParens;
      }

      if (openingParens === 0) {
        return [stringToReturn, i + 1 - indexToStartFrom];
      }
    }
  } else {
    // else wait until reading 'zero' or 'one' OR a number in the case it is called by getValue and has been replaced by a numbe
    for (var i = indexToStartFrom; i < array.length; ++i) {
      var term = array[i];
      stringToReturn = stringToReturn === "" ? term : stringToReturn + " " + term;

      if (term === "one" || term === "zero" || (0, _generalfunctions.isNumeric)(term)) {
        // ---
        return [stringToReturn, i + 1 - indexToStartFrom];
      }
    }
  }
}
/**
 * This is called to clean up a contract string prior to processing.
 * @param {string} inputString - The contract string to be checked.
 * @returns {string} The 'cleaned' contract string.
 */


function cleanUpBeforeDecomp(inputString) {
  // add dash between date day and time for processing purposes
  inputString = (0, _stringmanipulation.changeDateFormat)(inputString); // replacing own definitions with map values

  inputString = replaceUserDefinitions(inputString, definitionsMap);

  if (!correctConstruct(inputString)) {
    return "error";
  } // remove linebreaks, then multiple whitespaces


  inputString = inputString.replace(/(\r\n|\n|\r)/gm, " ").replace(/  +/gm, " "); // add spacing before and after parenthesis

  inputString = (0, _stringmanipulation.lTrimWhiteSpace)((0, _stringmanipulation.rTrimWhiteSpace)((0, _stringmanipulation.addSpacing)(inputString))); // evaluate & replace if clauses

  var ifMatches = inputString.match(/^(.*\sif\s.*)|(if\s.*)$/);

  if (ifMatches !== null) {
    inputString = (0, _stringmanipulation.rTrimWhiteSpace)((0, _stringmanipulation.lTrimWhiteSpace)(evaluateConditionals(inputString)));
  }

  return inputString;
}
/**
 * This function returns the input of the definitions text area.
 * @returns {string} The value of the definitions text area.
 */


global.getDefinitionsText = function () {
  return document.getElementById("add_input_textarea").value;
};
/**
 * This is called to extract all subhorizons from two given contracts.
 * @param {string} contract1 - The string representation of the first contract.
 * @param {string} contract2 - The string representation of the second contract.
 * @param {string} comparisonOperator - The comparison operator to be applied.
 * @returns {set} The set of subhorizons.
 */


function extractAllSubHorizons(contract1, contract2, comparisonOperator) {
  var setOfDates = new Set(); // whenever we reach one or zero we need to find their horizon ie we need to get the horizons of all lowest level subcontracts
  // simply by finding all truncate occurrences.. this is when a contracts value will change as some contract will expire

  var maxHorizon = "";

  if (comparisonOperator === ">=" || comparisonOperator === "==") {
    maxHorizon = getHorizon(contract2); // we only want to check for times that are <= maxHorizon
  } else {
    maxHorizon = getHorizon(contract1); // we only want to check for times that are <= maxHorizon
  }

  setOfDates.add(maxHorizon);

  if (comparisonOperator === "==") {
    return setOfDates;
  }

  var contract1HorArr = contract1.split(" "),
      contract2HorArr = contract2.split(" ");

  for (var i = 0; i < contract1HorArr.length; ++i) {
    var term = contract1HorArr[i];

    if (term === "truncate") {
      var currentHor = (0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(contract1HorArr[i + 1]));

      if ((0, _stringmanipulation.greaterDate)(maxHorizon, currentHor)) {
        setOfDates.add(currentHor);
      }
    }
  }

  for (var i = 0; i < contract2HorArr.length; ++i) {
    var term = contract2HorArr[i];

    if (term === "truncate") {
      var currentHor = (0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(contract2HorArr[i + 1]));

      if ((0, _stringmanipulation.greaterDate)(maxHorizon, currentHor)) {
        setOfDates.add(currentHor);
      }
    }
  }

  return setOfDates;
}
/**
 * This is called to check for expired contracts in the superContractsMap.
 */


function update() {
  // loop through all contracts and check if their time == current time and if so check if get or not
  // if get: then execute
  // if not get: then disable acquire button
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = superContractsMap[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          superContractId = _step2$value[0],
          contractsSet = _step2$value[1];

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = contractsSet[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var contract = _step3.value;

          if (contract.horizonDate !== "infinite" && (0, _stringmanipulation.beforeCurrentDate)(contract.horizonDate, "")) {
            if (contract.toBeExecutedAtHorizon === "yes") {
              // contract contains 'get' - must be executed now
              executeSingleContract(contract);
            } else {
              // contract just contains 'truncate' and not 'get'
              document.getElementById("td_status_" + contract.id).innerHTML = "expired";
              deleteFromSuperContracts(superContractsMap, superContractId, contract);
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}
/**
 * This is called to start a timer that is used for the update function.
 */


function runTimer() {
  // every 15 seconds we check for expired contracts
  var now = new Date(),
      timeToNextTick = 15000;
  setTimeout(function () {
    update();
    runTimer();
  }, timeToNextTick);
}
/**
 * This is called to deposit Ether into the specified account.
 * @param {number} id - Specifies whether the holder or the counter-party is depositing.
 */


global.callDepositFunction = function (id) {
  document.getElementById("create_contract_status").innerHTML = "";
  var addr = "";

  if (id === 1) {
    addr = "holder_address";
  } else {
    addr = "counter_party_address";
  }

  var depositAmount = getSelectedDeposit(),
      senderAddress = document.getElementById(addr).value;

  if ((0, _deploy.getSelectedMetaMaskAccount)().toUpperCase() === senderAddress.toUpperCase()) {
    (0, _deploy.depositCollateral)(senderAddress, depositAmount).then(function (holderDepositTxHash) {
      (0, _deploy.waitForReceipt)(holderDepositTxHash).then(function (_) {
        console.log("Deposit of " + depositAmount + " Ether has been added to " + addr + " account.");
        document.getElementById("select_deposit").disabled = true;

        if (id === 1) {
          account1Deposited = true;
        } else {
          account2Deposited = true;
        }

        if (account1Deposited && account2Deposited) {
          document.getElementById("make_transaction_button").disabled = false;
          document.getElementById("transaction_input_textarea").disabled = false;
        }

        retrieveBalances();
      });
    });
  } else {
    document.getElementById("create_contract_status").innerHTML = "Please change the currently selected MetaMask account to the one you would like to deposit to.";
  }
};
/**
 * This is called to create a smart contract on the blockchain.
 */


global.createContractFunction = function () {
  document.getElementById("create_contract_status").innerHTML = "";
  var localHolderAddress = document.getElementById("holder_address").value,
      localCounterPartyAddress = document.getElementById("counter_party_address").value;

  if (localHolderAddress === localCounterPartyAddress) {
    document.getElementById("create_contract_status").innerHTML = "Holder address and counter party address cannot be the same";
    return;
  } // check if getSelectedMetaMaskAccount returns valid result, if not log error telling user to log in


  if ((0, _deploy.getSelectedMetaMaskAccount)() === undefined) {
    document.getElementById("create_contract_status").innerHTML = "Please log into MetaMask.";
    return;
  } else {
    // check if the parity dev net is selected
    if ((0, _deploy.getSelectedNetwork)() !== "17") {
      document.getElementById("create_contract_status").innerHTML = "Please select the Parity development chain network.";
      return;
    }

    if ((0, _deploy.getSelectedMetaMaskAccount)().toUpperCase() === localHolderAddress.toUpperCase()) {
      (0, _deploy.setDefaultAccount)(localHolderAddress);
      (0, _deploy.instantiateNew)(localHolderAddress, localCounterPartyAddress).then(function (instantiationTxHash) {
        (0, _deploy.waitForReceipt)(instantiationTxHash).then(function (instantiationReceipt) {
          (0, _deploy.setSmartContractInstance)(instantiationReceipt.contractAddress);
          document.getElementById("create_contract_button").disabled = true;
          document.getElementById("select_oracle").disabled = true;
          document.getElementById("holder_address").disabled = true;
          document.getElementById("counter_party_address").disabled = true;
          document.getElementById("deposit_button1").disabled = false;
          document.getElementById("deposit_button2").disabled = false;
          document.getElementById("select_deposit").disabled = false;
          agreedOracleAddress = getSelectedOracle();
        });
      });
    } else {
      document.getElementById("create_contract_status").innerHTML = "Please change the currently selected MetaMask account to the contract holder account.";
    }
  }
};
/**
 * This is used to return the value of the "select_deposit" element
 */


function getSelectedDeposit() {
  return document.getElementById("select_deposit").value;
}
/**
 * This is used to return the value of the "select_oracle" element
 */


function getSelectedOracle() {
  return document.getElementById("select_oracle").value;
}
/**
 * This is used to return the value of the "transaction_input_textarea" element
 */


global.getInputString = function () {
  return document.getElementById("transaction_input_textarea").value;
};
/**
 * This is called to evaluate conditional statements contained within a contract string.
 * @param {string} inputString - The contract input string to be modified.
 * @returns {string} The modified contract string with conditional statements evaluated and removed.
 */


function evaluateConditionals(inputString) {
  var termArr = inputString.split(" "),
      ifsToBeMatched = 0,
      openingParens = 0,
      closingParens = 0,
      contractString = "",
      ifCondition = "",
      noOfOpeningParensStack = [],
      firstPartStack = [],
      compOpStack = [],
      insideCondition = false;

  for (var i = 0; i < termArr.length; ++i) {
    var term = termArr[i],
        nextTerm = termArr[i + 1],
        // for syntax checking
    prevTerm = termArr[i - 1]; // for syntax checking

    if (term === "if") {
      if (i > termArr.length - 9 || nextTerm !== "(" || i > 0 && prevTerm !== "(" && prevTerm !== "{" && prevTerm !== "and" && prevTerm !== "or" && !COMPARISONOPERATOR(prevTerm)) {
        document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
        return "error";
      }

      noOfOpeningParensStack.push(openingParens - closingParens);
      ++ifsToBeMatched;
      insideCondition = true;
    } else if (term === ")") {
      if (i < termArr.length - 1 && nextTerm !== ")" && nextTerm !== "and" && nextTerm !== "or" && nextTerm !== "{" && !COMPARISONOPERATOR(nextTerm) && nextTerm !== "||" && nextTerm !== "&&" || i < 2 || i > 0 && prevTerm !== "one" && prevTerm !== "zero" && prevTerm !== "}" && prevTerm !== ")") {
        document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
        return "error";
      }

      ++closingParens;
      var bool1 = noOfOpeningParensStack.length === 0 && openingParens === closingParens && ifsToBeMatched !== 0,
          bool2 = openingParens - noOfOpeningParensStack[noOfOpeningParensStack.length - 1] === closingParens;

      if (bool1 || bool2) {
        // have reached end of the if condition
        insideCondition = false;
        var firstPart = firstPartStack.pop(),
            compOp = compOpStack.pop(),
            cons = "",
            // consequence
        alt = "",
            // alternative
        bool = evaluate(firstPart, compOp, ifCondition);

        if (bool === undefined) {
          document.getElementById("transaction_status").innerHTML = "Conditional statement syntax error.";
          return "error";
        }

        ifCondition = "";
        var findConsequentResult1 = (0, _stringmanipulation.findConsequent)(termArr, i + 2); // +2 to skip {

        cons = findConsequentResult1[0];
        var lengthOfCons = findConsequentResult1[1];

        if (bool) {
          if (ifsToBeMatched > 1) {
            ifCondition = cons;
          } else {
            contractString = contractString === "" ? cons : contractString + " " + cons;
          } // now need to fast forward in string ie skip indices


          if (termArr[i + lengthOfCons + 2] !== "else") {
            i += lengthOfCons + 1; // +1 to skip {}
          } else {
            var findConsequentResult2 = (0, _stringmanipulation.findConsequent)(termArr, i + findConsequentResult1[1] + 4); // +4 because of 'else' + {

            alt = findConsequentResult2[0];
            var lengthOfAlt = findConsequentResult2[1];
            i += lengthOfCons + lengthOfAlt + 3; // +3 to skip {}{}
          }
        } else {
          // boolean returns false
          if (termArr[i + lengthOfCons + 2] !== "else") {
            // if no 'else' given
            i += lengthOfCons + 1; // +1 to skip {}

            if (ifsToBeMatched > 1) {
              // append result (nothing) to ifCondition
              ifCondition = "";
            } else {
              // append result (nothing) to contractString
              var slicedCond = contractString.slice(-3);

              if (slicedCond === "and" || slicedCond === " or") {
                // check if last term was a connective
                var lastIndex = contractString.lastIndexOf(" ");
                contractString = contractString.slice(0, lastIndex);
              } // check if last term was a comp op


              var slicedCompOp1 = ifCondition.slice(-4); // when compOp is 4 symbols long

              var slicedCompOp2 = ifCondition.slice(-2); // when compOp is 2 symbols long

              var slicedCompOp3 = ifCondition.slice(-1); // when compOp is 1 symbol long

              if (COMPARISONOPERATOR(slicedCond) || COMPARISONOPERATOR(slicedCompOp1) || COMPARISONOPERATOR(slicedCompOp2) || COMPARISONOPERATOR(slicedCompOp3)) {
                // check if last term was a connective
                document.getElementById("transaction_status").innerHTML = "Comparison operator error: Please provide an alternative to your conditional statement.";
                return "error";
              }
            } // check if next term is a comp op


            if (COMPARISONOPERATOR(termArr[i + 1])) {
              // check if next term is a connective
              document.getElementById("transaction_status").innerHTML = "Comparison operator error: Please provide an alternative to your conditional statement.";
              return "error";
            }

            if (termArr[i + 1] === "and" || termArr[i + 1] === "or") {
              // check if next term is a connective
              ++i;
            }
          } else {
            // there is an alternative
            var findConsequentResult2 = (0, _stringmanipulation.findConsequent)(termArr, i + findConsequentResult1[1] + 4); // +4 because of 'else' + {

            alt = findConsequentResult2[0];
            var lengthOfAlt = findConsequentResult2[1];
            i += lengthOfCons + lengthOfAlt + 3; // +4 to skip {}{}

            if (ifsToBeMatched > 1) {
              ifCondition = alt;
            } else {
              contractString = contractString === "" ? alt : contractString + " " + alt;
            }
          }
        }

        --ifsToBeMatched;
        noOfOpeningParensStack.pop();
      } else if (ifsToBeMatched <= 0 && !insideCondition) {
        // we are not inside ifCondition and can append to contractString
        contractString = contractString === "" ? term : contractString + " " + term;
      }
    } else if (term === "(") {
      if (i > termArr.length - 3 || nextTerm === ")" || COMPARISONOPERATOR(nextTerm) || nextTerm === "&&" || nextTerm === "||" || nextTerm === "{" || (0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(nextTerm))) || nextTerm === "}" || nextTerm === "or" || nextTerm === "and" || nextTerm === "else" || (0, _generalfunctions.isNumeric)(nextTerm) || observablesArr.includes(nextTerm) || i > 0 && (prevTerm === ")" || prevTerm === "one" || prevTerm === "zero" || prevTerm === "truncate" || prevTerm === "scaleK" || prevTerm === "else" || prevTerm === "}")) {
        document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
        return "error";
      }

      ++openingParens;

      if (termArr[i - 1] !== "if") {
        if (ifsToBeMatched <= 0 && !insideCondition) {
          // we are not inside ifCondition and can append to contractString
          contractString = contractString === "" ? term : contractString + " " + term;
        }
      }
    } else if (COMPARISONOPERATOR(term)) {
      if (firstPartStack.length === 0 || firstPartStack.length !== ifsToBeMatched) {
        firstPartStack.push(ifCondition);
      }

      compOpStack.push(term);
      ifCondition = "";
    } else if (term === "||" || term === "&&") {
      if (prevTerm !== ")" || nextTerm !== "(") {
        document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
        return "error";
      }

      var firstPart = firstPartStack.pop(),
          compOp = compOpStack.pop(),
          secondPart = ifCondition,
          ifConditionVal = evaluate(firstPart, compOp, secondPart);

      if (ifConditionVal === undefined) {
        document.getElementById("transaction_status").innerHTML = "Conditional statement syntax error.";
        return "error";
      } // keep opening paren


      ifCondition = firstPart.slice(0, 1) === "(" && secondPart.slice(-1) !== ")" ? "(" + ifConditionVal + " " + term : ifConditionVal + " " + term;

      if (ifConditionVal && term === "&&" || !ifConditionVal && term === "||") {
        // keep opening paren
        ifCondition = firstPart.slice(0, 1) === "(" && secondPart.slice(-1) !== ")" ? "(" : "";
      }
    } else if (nonExistingTerm(term)) {
      // give error for non-existing term
      document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
      return "error";
    } else {
      if (ifsToBeMatched > 0) {
        // we are inside ifCondition and do not want to add to final string
        ifCondition = ifCondition === "" ? term : ifCondition + " " + term;
      } else {
        // we are not inside ifCondition and can append to contractString
        contractString = contractString === "" ? term : contractString + " " + term;
      }
    }
  }

  return contractString;
}
/**
 * This is called to evaluate a conditional.
 * @param {string} part1 - The first part of the conditional.
 * @param {string} comparisonOperator - The comparison operator that is applied to the two parts.
 * @param {string} part2 - The second part of the conditional.
 * @returns {boolean} The boolean value of the conditional.
 */


function evaluate(part1, comparisonOperator, part2) {
  if (comparisonOperator === "{>}" || comparisonOperator === "{<}" || comparisonOperator === "{==}" || comparisonOperator === "{>=}" || comparisonOperator === "{<=}") {
    // Horizon Comparison
    // can only compare two contracts - cannot have a logical operator between two contracts
    // if no truncate included then horizon is infinite
    var horizon1 = getHorizon(part1),
        horizon2 = getHorizon(part2);

    switch (comparisonOperator) {
      case "{>=}":
        return !(0, _stringmanipulation.greaterDate)(horizon2, horizon1);

      case "{>}":
        return (0, _stringmanipulation.greaterDate)(horizon1, horizon2);

      case "{<=}":
        return !(0, _stringmanipulation.greaterDate)(horizon1, horizon2);

      case "{<}":
        return (0, _stringmanipulation.greaterDate)(horizon2, horizon1);

      case "{==}":
        return (0, _stringmanipulation.equalDates)(horizon1, horizon2);

      default:
    }
  } else if (comparisonOperator === "[>]" || comparisonOperator === "[<]" || comparisonOperator === "[==]" || comparisonOperator === "[>=]" || comparisonOperator === "[<=]") {
    // Value Comparison
    // can only compare two contracts - cannot have a logical operator between two contracts
    var value1 = getValue(part1, ""),
        value2 = getValue(part2, "");

    switch (comparisonOperator) {
      case "[>=]":
        return value1 >= value2;

      case "[>]":
        return value1 > value2;

      case "[<=]":
        return value1 <= value2;

      case "[<]":
        return value1 < value2;

      case "[==]":
        return value1 === value2;

      default:
    }
  } else if (comparisonOperator === ">=" || comparisonOperator === ">" || comparisonOperator === "<=" || comparisonOperator === "<" || comparisonOperator === "==") {
    // Dominance Comparison
    var horizon1 = getHorizon(part1),
        horizon2 = getHorizon(part2); // go through all dates and call getValue with date parameter

    switch (comparisonOperator) {
      case ">=":
        if (!(0, _stringmanipulation.greaterDate)(horizon2, horizon1)) {
          var horizonsSet = extractAllSubHorizons(part1, part2, comparisonOperator);
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = horizonsSet[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var hor = _step4.value;
              var value1 = getValue(part1, hor),
                  value2 = getValue(part2, hor);

              if (value1 < value2) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          return true;
        } else {
          return false;
        }

        break;

      case ">":
        return evaluate(part1, ">=", part2) && !evaluate(part1, "==", part2);

      case "<=":
        if (!(0, _stringmanipulation.greaterDate)(horizon1, horizon2)) {
          var horizonsSet = extractAllSubHorizons(part1, part2, comparisonOperator);
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = horizonsSet[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _hor = _step5.value;
              var value1 = getValue(part1, _hor),
                  value2 = getValue(part2, _hor);

              if (value1 > value2) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          return true;
        } else {
          return false;
        }

        break;

      case "<":
        return evaluate(part1, "<=", part2) && !evaluate(part1, "==", part2);

      case "==":
        if ((0, _stringmanipulation.equalDates)(horizon2, horizon1)) {
          var horizonsSet = extractAllSubHorizons(part1, part2, comparisonOperator);
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = horizonsSet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _hor2 = _step6.value;
              var value1 = getValue(part1, _hor2),
                  value2 = getValue(part2, _hor2);

              if (value1 !== value2) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          return true;
        } else {
          return false;
        }

        break;

      default:
    }
  }
}
/**
 * This is called to check whether a given string is a comparison operator.
 * @param {string} string - The string to be checked.
 * @returns {boolean} The boolean value specifying whether the string is a conditional or not.
 */


function COMPARISONOPERATOR(string) {
  if (string === "{>}" || string === "{<}" || string === "{==}" || string === "{>=}" || string === "{<=}" || string === "[>]" || string === "[<]" || string === "[==]" || string === "[>=]" || string === "[<=]" || string === ">=" || string === "==" || string === "<=" || string === ">" || string === "<") {
    return true;
  }

  return false;
}
/**
 * This is called to retrieve the horizon of a given contract string.
 * @param {string} contractString - The contract string of which the horizon should be returned.
 * @returns {string} The horizon of the contract.
 */


function getHorizon(contractString) {
  // Loops through the whole contract once to find the largest horizon
  // Find minimum horizon, but beforeCurrentDate() must return false
  var strArr = contractString.split(" "),
      maxHorizon = "",
      // setting first horizon as empty string
  comeAcrossTruncate = false;

  for (var i = 0; i < strArr.length; ++i) {
    if (strArr[i] === "truncate") {
      // obtain c from 'truncate t c'
      var oscs = obtainSubContractString(strArr, i + 2),
          c = oscs[0],
          prevHorizon = getHorizon(c),
          // obtain c's previous horizon
      currentHor = (0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(strArr[i + 1])); // compare previous horizon with new horizon t and get min

      if ((0, _stringmanipulation.greaterDate)(currentHor, prevHorizon)) {
        currentHor = prevHorizon;
      }

      comeAcrossTruncate = true;

      if (maxHorizon === "" || (0, _stringmanipulation.greaterDate)(currentHor, maxHorizon)) {
        maxHorizon = currentHor;
      }

      i += oscs[1];
    } else if (strArr[i] === "and" || strArr[i] === "or") {
      // have reached end of subcontract
      if (!comeAcrossTruncate) {
        // if we have not come across a "truncate" then this subcontract's horizon is infinite
        return "infinite";
      }

      comeAcrossTruncate = false;
    } else if (i === strArr.length - 1 && !comeAcrossTruncate) {
      return "infinite";
    }
  }

  return maxHorizon;
}
/**
 * This is called to decompose a given contract string.
 * @param {array} termArr - The contract string to decompose split by whitespaces.
 * @returns {array} An array containing the first and second subcontract, the type of the most balanced connective,
 * the string to be added to the beginning, as well as the string to be added to the end of the following contract.
 */


function decompose(termArr) {
  // decomposes contract by most external connective
  var openingParens = 0,
      closingParens = 0,
      contractString = "",
      contractParsed = "",
      parseStack = [],
      contractsStack = [],
      closingParensStack = [],
      mostBalancedCon = "",
      mostBalancedConBalance = termArr.length - 1,
      secondPartString = "",
      stringToAddToBeginning = "",
      stringToAddToEnd = "",
      conWaitingToBeMatched = false; // set to true when reading conjunction and then set to false when reading another conjunction or reaching end

  for (var i = 0; i < termArr.length; ++i) {
    var term = termArr[i];

    if (term === "and" || term === "or") {
      // we have reached the end of a subcontract whenever 'and' is read
      if (openingParens === closingParens) {
        // found outer most conjunct
        mostBalancedCon = term;
        contractsStack[0] = contractParsed;
        contractsStack[1] = termArr.slice(i + 1).join(' ');
        stringToAddToBeginning = "";
        stringToAddToEnd = "";

        if (termArr[i - 1] === ")" && termArr[i + 1] === "(") {
          contractsStack[0] = (0, _stringmanipulation.lTrimParen)((0, _stringmanipulation.rTrimParen)(contractsStack[0]));
          contractsStack[1] = (0, _stringmanipulation.lTrimParen)((0, _stringmanipulation.rTrimParen)(contractsStack[1]));
        }

        return [contractsStack[0], contractsStack[1], mostBalancedCon, "", ""];
      } else if (openingParens - closingParens < mostBalancedConBalance) {
        // found a new most balanced connective
        mostBalancedConBalance = openingParens - closingParens;
        mostBalancedCon = term;
        var combinatorString = parseStack[parseStack.length - 1];
        var closingParensString = closingParensStack[closingParensStack.length - 1];

        if (combinatorString !== undefined) {
          if (mostBalancedCon === "or") {
            contractsStack[0] = contractString;
            stringToAddToBeginning = combinatorString + " ( ";
            stringToAddToEnd = closingParensString;
          } else {
            contractsStack[0] = contractParsed + closingParensString;
          }
        } else {
          contractsStack[0] = contractParsed;
        }

        contractString = "";
        conWaitingToBeMatched = true;
      } else {
        // ie conjWaitingToBeMatched
        secondPartString = secondPartString === "" ? term : secondPartString + " " + term;

        if (conWaitingToBeMatched) {
          contractString = contractString === "" ? term : contractString + " " + term;
        }
      }
    } else if (term === "zero" || term === "one") {
      var combinatorString = parseStack[parseStack.length - 1];
      var closingParensString = closingParensStack[closingParensStack.length - 1];

      if (conWaitingToBeMatched) {
        secondPartString = secondPartString === "" ? term : secondPartString + " " + term;
      }

      contractString = contractString === "" ? term : contractString + " " + term;
    } else if (term === ")") {
      var combinatorString;
      var closingParensString;

      if (!conWaitingToBeMatched) {
        combinatorString = parseStack.pop();
        closingParensString = closingParensStack.pop();
      }

      var bool1 = openingParens - closingParens === mostBalancedConBalance;
      var bool2 = openingParens - closingParens === mostBalancedConBalance + 1 && termArr[0] === "(";
      var bool = bool1 || bool2;

      if (secondPartString !== "" && conWaitingToBeMatched && bool) {
        secondPartString = closingParensString !== undefined ? secondPartString + closingParensString : secondPartString + " " + term;

        if (mostBalancedCon === "or") {
          contractsStack[1] = secondPartString;
        } else {
          // connective is "and"
          if (combinatorString !== undefined) {
            if (secondPartString[0] !== "(") {
              contractsStack[1] = stringToAddToBeginning !== "" ? stringToAddToBeginning + " ( " + combinatorString + " ( " + secondPartString : combinatorString + " ( " + secondPartString;
            } else {
              contractsStack[1] = stringToAddToBeginning !== "" ? stringToAddToBeginning + " ( " + combinatorString + " " + secondPartString : combinatorString + " " + secondPartString;
            }
          } else if (closingParensString !== undefined) {
            contractsStack[1] = stringToAddToBeginning !== "" ? stringToAddToBeginning + " ( " + secondPartString : "( " + secondPartString;
          } else {
            contractsStack[1] = stringToAddToBeginning !== "" ? stringToAddToBeginning + " " + secondPartString : secondPartString;
          }
        }

        secondPartString = "";
      }

      contractString = "";
      ++closingParens;
    } else if (term === "(") {
      ++openingParens;

      if (contractString !== "" && openingParens - closingParens < mostBalancedConBalance) {
        if (parseStack.length > 0) {
          parseStack.push(parseStack[parseStack.length - 1] + " ( " + contractString);
        } else {
          parseStack.push(contractString);
        }
      }

      if (termArr[i - 1] !== "and" && i !== 0) {
        if (closingParensStack.length === 0) {
          closingParensStack.push(" )");
        } else {
          closingParensStack.push(closingParensStack[closingParensStack.length - 1] + " )");
        }
      }

      if (conWaitingToBeMatched) {
        secondPartString = secondPartString === "" ? term : secondPartString + " " + term;
      }

      contractString = "";
    } else {
      if (conWaitingToBeMatched) {
        secondPartString = secondPartString === "" ? term : secondPartString + " " + term;
      }

      contractString = contractString === "" ? term : contractString + " " + term;
    }

    contractParsed = contractParsed === "" ? term : contractParsed + " " + term;
  } // this happens if there is a balanced or conjunction at the end and the second part still needs to be added


  return [(0, _stringmanipulation.cleanParens)(contractsStack[0]), (0, _stringmanipulation.cleanParens)(contractsStack[1]), mostBalancedCon, stringToAddToBeginning, stringToAddToEnd];
}
/**
 * This is called to retrieve the value of a given contract string.
 * @param {string} contractString - The contract string of which the value should be returned.
 * @param {string} horizonToCheck - The horizon against which the value should be checked.
 * @returns {number} The value of the contract.
 */


function getValue(contractString, horizonToCheck) {
  var termArr = contractString.split(" "),
      currentString = "",
      combinatorStack = [],
      currentVal;

  for (var i = 0; i < termArr.length; ++i) {
    var term = termArr[i];

    if (term === "(") {
      if (currentString !== "") {
        combinatorStack.push(currentString);
        currentString = "";
      }
    } else if (term === ")") {
      // whenever we read this we can evaluate current contract string and pop 1 comb off the combinators stack to apply
      currentVal = getLowestLevelContractValue(currentString, horizonToCheck);

      if (combinatorStack.length > 0) {
        var str = combinatorStack.pop() + " " + currentVal.toString();
        currentVal = getLowestLevelContractValue(str, horizonToCheck);
      }

      if (currentVal !== undefined) {
        currentString = i === termArr.length - 1 ? "" : currentVal.toString();
      } // apply combinator to it and call getValue again

    } else if (term === "get") {
      var oscs = obtainSubContractString(termArr, i + 1);
      var subContractString = oscs[0];
      var tempValue = getValue(subContractString, horizonToCheck);
      currentVal = (0, _stringmanipulation.sameDayAsCurrentDate)(getHorizon(subContractString), horizonToCheck) ? tempValue : 0;

      if (currentVal !== undefined) {
        currentString = i === termArr.length - 1 ? "" : currentVal.toString();
      }

      i += oscs[1];
    } else {
      currentString = currentString === "" ? term : currentString + " " + term;
    }
  }

  if (currentString !== "") {
    currentVal = getLowestLevelContractValue(currentString, horizonToCheck);
  }

  return currentVal;
}
/**
 * This is called by the getValue function to retrieve the value of a contract consisting of two combined subcontracts.
 * @param {string} contractString - The contract string of which the value should be returned.
 * @param {string} horizonToCheck - The horizon against which the value should be checked.
 * @returns {number} The value of the contract.
 */


function getLowestLevelContractValue(contractString, horizonToCheck) {
  if (contractString.includes(" or ")) {
    // it will only contain one or the other, not both
    var arr = contractString.split(" or ");
    return Math.max(getLowestLevelContractValue(arr[0], horizonToCheck), getLowestLevelContractValue(arr[1], horizonToCheck));
  } else if (contractString.includes(" and ")) {
    var arr = contractString.split(" and ");
    return getLowestLevelContractValue(arr[0], horizonToCheck) + getLowestLevelContractValue(arr[1], horizonToCheck);
  } else {
    // string does not contain connective ie we are in lowest-level subcontract
    if ((0, _generalfunctions.isNumeric)(contractString)) {
      return parseFloat(contractString);
    } else if (contractString === "zero" || contractString.includes(" zero ") || contractString === "0" || contractString.includes(" 0 ")) {
      return 0;
    } else if (contractString === "one") {
      return 1;
    } else {
      var value = 1;
      var horizon = getHorizon(contractString);
      var termArr = contractString.split(" ");

      for (var i = 0; i < termArr.length; ++i) {
        if (termArr[i] === "scaleK") {
          if (termArr[i + 1].includes("x")) {
            // value dependent on some observable values
            var arr = termArr[i + 1].split("x");

            for (var j = 0; j < arr.length; ++j) {
              if ((0, _generalfunctions.isNumeric)(arr[j])) {
                value = value * parseFloat(arr[j]);
              } else {
                // we encountered an observable
                if (arr[j] === "libor3m") {
                  // rounding because Parity can only handle integers
                  value = Math.round(value * (0, _oracles.getOracleByAddress)(agreedOracleAddress).getLiborSpotRate());
                } else if (arr[j] === "tempInLondon") {
                  value = Math.round(value * (0, _oracles.getOracleByAddress)(agreedOracleAddress).getTempInLondon());
                }
              }
            }
          } else {
            value = value * parseFloat(termArr[i + 1]);
          }

          ++i;
        } else if (termArr[i] === "give") {
          value = -value;
        } else if ((0, _generalfunctions.isNumeric)(termArr[i])) {
          value = value * parseFloat(termArr[i]);
        }
      }

      if ((0, _stringmanipulation.beforeCurrentDate)(horizon, horizonToCheck)) {
        // ie contract has expired, its horizon is before horizonToCheck
        return 0;
      } else {
        // contract's horizon is after the horizon given, so it is valid
        return value;
      }
    }
  }
}
/**
 * This is called to process a contract provided by the end user.
 * @param {string} inputString - The contract string provided by the end user.
 * @param {boolean} initialDecomposition - A boolean specifying whether this is an initial decomposition called from pressing the 'make transaction' button.
 * @param {boolean} firstOrHasBeenDecomposed - A boolean specifying whether the first 'or' connective has been decomposed yet.
 * @param {number} contractOwner - This specifies whether the holder is paying or receiving the specified amount in the contract.
 */


global.processContract = function (inputString, initialDecomposition, firstOrHasBeenDecomposed, contractOwner) {
  ++uniqueID;

  if (initialDecomposition) {
    // This is the case only when this function is triggered by the 'make transaction' button
    contractsBeingDecomposed = 1;
    removeChildren("button_choices_container");
    acquireBtnToBeDisabled1 = true;
    acquireBtnToBeDisabled2 = true;
    document.getElementById("transaction_status").innerHTML = "";
  }

  inputString = cleanUpBeforeDecomp(inputString);

  if (inputString === "error" || !parsesSuccessfullyForSyntax(inputString)) {
    return;
  }

  var termArr = inputString.split(" "); // check if inputstring contains 'or' else execute right away

  var orMatches = inputString.match(/^(.*)\sor\s(.*)$/);

  if (orMatches !== null) {
    // keep track of the current most balanced conj AND its external combinators
    var decomposedResult = decompose(termArr),
        part1 = decomposedResult[0],
        part2 = decomposedResult[1],
        mostBalancedConj = decomposedResult[2];

    if (mostBalancedConj === "and") {
      ++contractsBeingDecomposed;
      processContract(part1, false, firstOrHasBeenDecomposed, contractOwner);
      processContract(part2, false, firstOrHasBeenDecomposed, contractOwner);
    } else {
      // conn is "or"
      // uncomment for testing performance

      /*
      ++contractsBeingDecomposed;
      processContract(part1, false, firstOrHasBeenDecomposed, contractOwner);
      processContract(part2, false, firstOrHasBeenDecomposed, contractOwner);
      */
      // comment for testing performance

      /**/
      if (!firstOrHasBeenDecomposed) {
        var occ = (0, _generalfunctions.occurrences)(decomposedResult[3], "give ", false);
        contractOwner = occ % 2 === 0 ? 0 : 1; // setting the owner for all future contract choices
      }

      firstOrHasBeenDecomposed = true;
      addChoices([part1, part2], decomposedResult[3], decomposedResult[4], uniqueID, contractOwner);
      /**/
    }
  } else {
    // input does not contain 'or'
    var contractsArr = decomposeAnds(inputString); // calling this for performance reasons - decomposeAnds will not recursively call itself

    contractsBeingDecomposed = contractsBeingDecomposed + contractsArr.length - 1;
    createContractEntries(contractsArr);
  }
};
/**
 * This is called to create a select item in the UI allowing users to evaluate supercontracts.
 * @param {tr} tr - The table row element to be used.
 * @param {string} id - The contract id.
 */


function createValuationSelect(tr, id) {
  var td;
  tr.appendChild(td = document.createElement("td"));
  var div = document.createElement("div");
  td.appendChild(div);
  div.className = "valuation_cell_data";
  var date = new Date(),
      d = date.getDate(),
      m = date.getMonth(),
      y = date.getFullYear();
  var selectDay = document.createElement("select");
  selectDay.className = "select_valuation";
  selectDay.id = "day_select_" + id;

  selectDay.onchange = function () {
    updateValuationValue(id);
  };

  div.appendChild(selectDay);

  for (var i = 1; i <= 31; i++) {
    var option = document.createElement("option");
    option.value = i;
    option.text = i;
    selectDay.appendChild(option);
  }

  selectDay.value = d;
  var selectMonth = document.createElement("select");
  selectMonth.className = "select_valuation";
  selectMonth.id = "month_select_" + id;

  selectMonth.onchange = function () {
    var selectedMonth = selectMonth.value;
    updateSelectableDaysFromMonth(selectedMonth, id);
    updateValuationValue(id);
  };

  div.appendChild(selectMonth);

  for (var i = 1; i <= 12; i++) {
    var option = document.createElement("option");
    option.value = i;
    option.text = i;
    selectMonth.appendChild(option);
  }

  selectMonth.value = m + 1;
  var selectYear = document.createElement("select");
  selectYear.className = "select_valuation_year";
  selectYear.id = "year_select_" + id;

  selectYear.onchange = function () {
    var selectedYear = selectYear.value;
    updateSelectableDaysFromYear(selectedYear, id);
    updateValuationValue(id);
  };

  div.appendChild(selectYear);

  for (var i = 2019; i <= 2040; i++) {
    var option = document.createElement("option");
    option.value = i;
    option.text = i;
    selectYear.appendChild(option);
  }

  selectYear.value = y;
  var valueLabel = document.createElement("p");
  td.appendChild(valueLabel);
  valueLabel.id = "p_value_" + id;
  valueLabel.className = "p_value";
  updateValuationValue(id);
}
/**
 * This is called to update the value in the valuation select item.
 * @param {string} id - The contract id.
 */


function updateValuationValue(id) {
  var day = (0, _stringmanipulation.padNumber)(document.getElementById("day_select_" + id).value),
      month = (0, _stringmanipulation.padNumber)(document.getElementById("month_select_" + id).value),
      year = document.getElementById("year_select_" + id).value,
      c = getAllSubcontracts(id);
  document.getElementById("p_value_" + id).innerHTML = getValue(c, day + "/" + month + "/" + year + "-" + "12:00:00").toString() + "ETH";
}
/**
 * This is called to retrieve all subcontracts from a given super contract using superContractsMap.
 * @param {string} superKey - The key of the super contract used to look up the subcontracts.
 * @returns {string} The contract string containing all subcontracts combined with the 'and' connective
 */


function getAllSubcontracts(superKey) {
  var finalContractString = "";

  if (superContractsMap.has(superKey)) {
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = superContractsMap[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var _step7$value = _slicedToArray(_step7.value, 2),
            superContractId = _step7$value[0],
            contractsSet = _step7$value[1];

        if (superContractId === superKey) {
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = contractsSet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var contract = _step8.value;
              finalContractString = finalContractString === "" ? contract.contractString : finalContractString + " and " + contract.contractString;
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                _iterator8["return"]();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
          _iterator7["return"]();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }

    return finalContractString;
  } else {
    return "zero"; // all contracts have already expired
  }
}
/**
 * This is called to retrieve all subcontracts from a given super contract using superContractsMap.
 * @param {string} superKey - The key of the super contract used to look up the subcontracts.
 * @returns {string} The contract string containing all subcontracts combined with the 'and' connective
 */


function updateSelectableDaysFromMonth(selectedMonth, id) {
  var selectDay = document.getElementById("day_select_" + id);
  var selectYear = document.getElementById("year_select_" + id);

  if (selectedMonth === "1" || selectedMonth === "3" || selectedMonth === "5" || selectedMonth === "7" || selectedMonth === "8" || selectedMonth === "10" || selectedMonth === "12") {
    // 31 days
    for (var i = selectDay.options.length + 1; i <= 31; ++i) {
      // add items
      var option = document.createElement("option");
      option.value = i;
      option.text = i;
      selectDay.appendChild(option);
    }
  } else if (selectedMonth === "2") {
    if (selectYear === "2020" || selectYear === "2024" || selectYear === "2028" || selectYear === "2032" || selectYear === "2036" || selectYear === "2040") {
      // leap year - 29 days in Feb
      if (parseInt(selectDay.value) > 29) {
        selectDay.value = 29;
      }

      while (selectDay.options.length > 29) {
        selectDay.remove(29);
      }

      if (selectDay.options.length === 28) {
        var option = document.createElement("option");
        option.value = "29";
        option.text = "29";
        selectDay.appendChild(option);
      }
    } else {
      // 28 days in Feb
      if (parseInt(selectDay.value) > 28) {
        selectDay.value = 28;
      }

      while (selectDay.options.length > 28) {
        selectDay.remove(28);
      }
    }
  } else {
    // 30 days
    if (parseInt(selectDay.value) > 30) {
      selectDay.value = 30;
    }

    if (selectDay.options.length > 30) {
      selectDay.remove(30);
    }

    for (var i = selectDay.options.length + 1; i <= 30; ++i) {
      // add items
      var option = document.createElement("option");
      option.value = i;
      option.text = i;
      selectDay.appendChild(option);
    }
  }
}
/**
 * This is called to update the values in the valuation select item. This is to prevent
 * impossible dates like 31/02/2019 from being displayed
 * @param {string} selectedYear - The year that has been selected.
 * @param {string} id - The contract id.
 */


function updateSelectableDaysFromYear(selectedYear, id) {
  var selectDay = document.getElementById("day_select_" + id);
  var selectMonth = document.getElementById("month_select_" + id);

  if (selectMonth.value === "2") {
    if (selectedYear === "2020" || selectedYear === "2024" || selectedYear === "2028" || selectedYear === "2032" || selectedYear === "2036" || selectedYear === "2040") {
      // leap year - 29 days in Feb
      if (parseInt(selectDay.value) > 29) {
        selectDay.value = 29;
      }

      while (selectDay.options.length > 29) {
        // remove items first
        selectDay.remove(29);
      }

      if (selectDay.options.length === 28) {
        var option = document.createElement("option");
        option.value = "29";
        option.text = "29";
        selectDay.appendChild(option);
      }
    } else {
      // 28 days in Feb
      if (parseInt(selectDay.value) > 28) {
        selectDay.value = 28;
      }

      while (selectDay.options.length > 28) {
        selectDay.remove(28);
      }
    }
  }
}
/**
 * This is called to create the acquire button in the table of pending contracts.
 * @param {tr} tr - The table row element to be used.
 * @param {string} id - The contract id.
 */


function createAcquireButton(tr, id) {
  var td;
  tr.appendChild(td = document.createElement("td")); //Create array of options to be added

  var btn = document.createElement('input');
  btn.type = "button";
  btn.className = "acquire_button button";
  btn.id = "acquire_button_" + id;
  btn.value = "acquire";

  btn.onclick = function (_) {
    executeSuperContract(id);
  };

  td.appendChild(btn); // if either of these is true then we want the acquire button to be disabled

  if (acquireBtnToBeDisabled1 || acquireBtnToBeDisabled2) {
    btn.disabled = true;
  }
}
/**
 * This is called to present the user with disjunct contract choices in the UI.
 * @param {array} contractsStack - The array of contracts to be displayed.
 * @param {string} beginningStr - The string to be added to the beginning after a contract choice has been made.
 * @param {string} endStr - The string to be appended after a contract choice has been made.
 * @param {number} divId - An integer identifying the div of the choice.
 * @param {number} owner = Specifies whether the holder or the counter-party owns the contract.
 */


function addChoices(contractsStack, beginningStr, endStr, divId, owner) {
  var contract2 = contractsStack.pop();
  var contract1 = contractsStack.pop();
  createSection(divId);
  createButton((0, _stringmanipulation.rTrimWhiteSpace)((0, _stringmanipulation.lTrimWhiteSpace)(contract1)), beginningStr, endStr, 1, divId, owner);
  createOrLabel(divId);
  createButton((0, _stringmanipulation.rTrimWhiteSpace)((0, _stringmanipulation.lTrimWhiteSpace)(contract2)), beginningStr, endStr, 2, divId, owner);
  stringToAddToBeginning = "";
  stringToAddToEnd = "";
}
/**
 * This is called to create contract entries in the UI from a given array of contracts.
 * @param {array} contractsArr - The array of contracts to be displayed.
 */


function createContractEntries(contractsArr) {
  // acquire button should be disabled if either all contracts are expired or all contracts are to be acquired at horizon ie 'get'
  for (var i = 0; i < contractsArr.length; ++i) {
    var conString = (0, _stringmanipulation.cleanParens)((0, _stringmanipulation.lTrimWhiteSpace)((0, _stringmanipulation.rTrimWhiteSpace)(contractsArr[i])));

    if (!conString.includes("get")) {
      // at least one contract is not acquired at its horizon
      acquireBtnToBeDisabled1 = false;
    }

    if (!(0, _stringmanipulation.beforeCurrentDate)(getHorizon(conString), "")) {
      // at least one subcontract has not expired yet
      acquireBtnToBeDisabled2 = false;
    }

    createContractObject(conString);
  }
}
/**
 * This is called when decomposing a contract and the contract itself contains no more 'or' connectives
 * @param {string} contractString - The contract string to be decomposed.
 * @returns {array} The array containing all subcontracts in the given contract string.
 */


function decomposeAnds(contractString) {
  // keep two stacks: one for combinators and one for closing parenthesis to be added
  var termArr = contractString.split(" "),
      openingParens = 0,
      contractString = "",
      parseStack = [],
      finalContractsArr = [],
      closingParensStack = [];

  for (var i = 0; i < termArr.length; ++i) {
    var term = termArr[i];

    if (term === "and") {
      // we have reached the end of a subcontract whenever 'and' is read
      if (contractString !== "") {
        if (openingParens === 0) {
          finalContractsArr.push(contractString);
        } else if (parseStack.length > 0) {
          finalContractsArr.push(parseStack[parseStack.length - 1] + " ( " + contractString + closingParensStack[closingParensStack.length - 1]);
        } else if (closingParensStack.length > 0) {
          finalContractsArr.push(contractString + closingParensStack[closingParensStack.length - 1]);
        } else {
          finalContractsArr.push(contractString);
        }

        contractString = "";
      }
    } else if (term === ")") {
      // as soon as closing paren is read we have found a contract
      --openingParens;
      var combinatorString = parseStack.pop();
      var closingParensString = closingParensStack.pop();

      if (contractString !== "") {
        if (combinatorString !== undefined && closingParensString !== undefined) {
          finalContractsArr.push(combinatorString + " ( " + contractString + closingParensString);
        } else {
          finalContractsArr.push(contractString);
        }

        contractString = "";
      }
    } else if (term === "(") {
      ++openingParens;

      if (contractString !== "") {
        if (parseStack.length > 0) {
          parseStack.push(parseStack[parseStack.length - 1] + " ( " + contractString);
        } else {
          parseStack.push(contractString);
        }

        contractString = "";
      }

      if (termArr[i - 1] !== "and" && i !== 0) {
        if (closingParensStack.length === 0) {
          closingParensStack.push(" )");
        } else {
          closingParensStack.push(closingParensStack[closingParensStack.length - 1] + " )");
        }
      }
    } else {
      contractString = contractString === "" ? term : contractString + " " + term;
    }
  } // this happens if there is a balanced or conjunction at the end and the second part still needs to be added


  if (contractString !== "") {
    finalContractsArr.push(contractString);
  }

  return finalContractsArr;
}
/**
 * This is called to check the syntax of a contract string.
 * @param {string} contractString - The contract string to be decomposed.
 * @returns {boolean} A boolean value specifying whether the given contract is correct.
 */


function parsesSuccessfullyForSyntax(contractString) {
  var strArr = contractString.split(" ");

  for (var i = 0; i < strArr.length; ++i) {
    var term = strArr[i],
        prevTerm = strArr[i - 1],
        nextTerm = strArr[i + 1];

    switch (term) {
      case "zero":
        if (i < strArr.length - 1 && nextTerm !== "and" && nextTerm !== "or" && nextTerm !== ")") {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

        break;

      case "one":
        if (i < strArr.length - 1 && nextTerm !== "and" && nextTerm !== "or" && nextTerm !== ")") {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

        break;

      case "and":
        if (i > 0 && prevTerm !== ")" && prevTerm !== "one" && prevTerm !== "zero" || nextTerm === ")" || nextTerm === "and" || nextTerm === "or" || (0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(nextTerm))) || (0, _generalfunctions.isNumeric)(nextTerm) || observablesArr.includes(nextTerm)) {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

        break;

      case "or":
        if (i > 0 && prevTerm !== ")" && prevTerm !== "one" && prevTerm !== "zero" || nextTerm === ")" || nextTerm === "and" || nextTerm === "or" || (0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(nextTerm))) || (0, _generalfunctions.isNumeric)(nextTerm) || observablesArr.includes(nextTerm)) {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

        break;

      case "truncate":
        if (i > strArr.length - 3 || i < strArr.length - 1 && !(0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(nextTerm)))) {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": truncate should be followed by a date in the following pattern: 'dd/mm/yyyy hh:mm:ss'.";
          return false;
        }

        break;

      case "get":
        if (i < strArr.length - 1 && nextTerm !== "(") {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": get should be followed by opening parenthesis.";
          return false;
        }

        break;

      case "scaleK":
        if (i > strArr.length - 3 || i < strArr.length - 1 && !(0, _generalfunctions.isNumeric)(nextTerm) && !observablesArr.includes(nextTerm)) {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": scaleK should be followed by an integer or an observable.";
          return false;
        }

        break;

      case "give":
        if (i === strArr.length - 1 || i < strArr.length - 1 && nextTerm !== "(") {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": give should be followed by opening parenthesis.";
          return false;
        }

        break;

      case "(":
        if (i > strArr.length - 3 || prevTerm === "one" || prevTerm === "zero" || prevTerm === ")" || prevTerm === "scaleK" || prevTerm === "truncate" || nextTerm === "and" || nextTerm === "or" || nextTerm === ")" || (0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(nextTerm))) || (0, _generalfunctions.isNumeric)(nextTerm) || observablesArr.includes(nextTerm)) {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

        break;

      case ")":
        if (i > 0 && prevTerm !== ")" && prevTerm !== "one" && prevTerm !== "zero" || i < 2 || i < strArr.length - 1 && nextTerm !== ")" && nextTerm !== "and" && nextTerm !== "or") {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

        break;

      default:
        if ((0, _generalfunctions.isNumeric)(term) || observablesArr.includes(term)) {
          if (i === 0 || i === strArr.length - 1 || prevTerm !== "scaleK" || nextTerm !== "(") {
            document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": a float/observable value should be after scaleK and the float/observable should be followed by parenthesis.";
            return false;
          }
        } else if ((0, _stringmanipulation.isDate)((0, _stringmanipulation.lTrimDoubleQuotes)((0, _stringmanipulation.rTrimDoubleQuotes)(term)))) {
          if (i === 0 || i === strArr.length - 1 || prevTerm !== "truncate" || nextTerm !== "(") {
            document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": a date should be after truncate and the date should be followed by parenthesis.";
            return false;
          }
        } else {
          document.getElementById("transaction_status").innerHTML = "Syntax error at term " + i.toString() + ": " + term;
          return false;
        }

    }
  }

  return true;
}
/**
 * This is called to create a single Contract object from a given contract string.
 * @param {string} inputString - The contract string to be used.
 */


function createContractObject(inputString) {
  // this is a lowest-level subcontract, ie. it contains only 1 occurrence zero/one
  var giveOccurrences = 0,
      getOccurrences = 0,
      getHasAppeared = false,
      // to make sure gets are followed by a truncate
  amount = "1",
      contractObsArr = [];

  if (inputString.includes(" zero ") || inputString.includes(" zero") || inputString === "zero") {
    amount = "0";
  }

  var horizonDate = getHorizon(inputString);
  var newStr = inputString.replace(/[()]/g, ''); // removing parenthesis

  var strArr = newStr.split(" ");

  for (var i = 0; i < strArr.length; ++i) {
    var str = strArr[i];

    if (str === "give") {
      ++giveOccurrences;
    } else if (str === "scaleK" && amount !== "0") {
      if ((0, _generalfunctions.isNumeric)(strArr[i + 1])) {
        amount = (parseFloat(amount) * parseFloat(strArr[i + 1])).toString();
        ++i;
      } else if (observablesArr.includes(strArr[i + 1])) {
        contractObsArr.push(strArr[i + 1]);
        ++i;
      }
    } else if (str === "get") {
      getHasAppeared = true;
      ++getOccurrences;
    } else if (str === "truncate") {
      // to make sure gets are followed by a truncate
      getHasAppeared = false;
    }
  }

  if (getHasAppeared) {
    document.getElementById("transaction_status").innerHTML = "Syntax error: get must be followed by truncate.";
    addSuperContractRow();
    return;
  }

  var recipient = giveOccurrences % 2 === 0 ? 0 : 1,
      acquireAtHorizon = getOccurrences % 2 === 0 ? "no" : "yes",
      contractString = (0, _contract.createNewContractString)(amount, contractObsArr, recipient, horizonDate, acquireAtHorizon);
  var contract = new _contract.Contract(numberOfContracts.toString() + "." + numberOfSubContracts.toString(), amount, contractObsArr, recipient, contractString, (0, _contract.translateContract)(recipient, amount, contractObsArr, horizonDate, acquireAtHorizon), horizonDate, acquireAtHorizon, "waiting to be executed");
  var balanceLabel = recipient === 1 ? document.getElementById("holder_balance_p").innerHTML.split() : document.getElementById("counter_party_balance_p").innerHTML;
  var regex = new RegExp("(Balance:\\s)(.+)(ETH)");
  var matchObj = regex.exec(balanceLabel); // cannot check Rust balance as this will cause a delay. However, this is fine since label balance gets updated directly after transfer

  var balance = parseFloat(matchObj[2]); // uncomment this for testing, comment below - > there will be no super contract row
  // createTableRow(contract); // TESTING

  if (balance >= parseFloat(amount) && enoughBalanceForCapacity(contract, balance)) {
    createTableRow(contract);
    ++numberOfSubContracts;

    if (horizonDate !== "infinite" && (0, _stringmanipulation.beforeCurrentDate)(contract.horizonDate, "")) {
      // add expired label
      document.getElementById("td_status_" + contract.id).innerHTML = "expired";
    } else {
      addToSuperContracts(superContractsMap, numberOfContracts.toString(), contract); // contract is only added to pending contracts map if it is still valid

      document.getElementById("td_status_" + contract.id).innerHTML = "waiting to be executed";
    }

    addSuperContractRow();
  } else {
    document.getElementById("transaction_status").innerHTML = "Insufficient funds. The sending party does not have enough Ether in their account. Please deposit before adding additional contracts.";
    addSuperContractRow();
  }
}
/**
 * This is called to add a supercontract row to the table of pending contracts in the case where all subcontracts have been added.
 */


function addSuperContractRow() {
  --contractsBeingDecomposed;

  if (!document.getElementById("button_choices_container").hasChildNodes() && contractsBeingDecomposed === 0 && numberOfSubContracts !== 0) {
    // now we can add the super contract row
    var tr = document.getElementById("my_table").insertRow(1);
    tr.className = "super_contract_row";
    var td;
    tr.appendChild(td = document.createElement("td"));
    var superContractKey = numberOfContracts.toString();
    td.innerHTML = superContractKey;

    for (var i = 0; i < 5; ++i) {
      tr.appendChild(td = document.createElement("td"));
    }

    createValuationSelect(tr, superContractKey);
    createAcquireButton(tr, superContractKey);
    ++numberOfContracts;
    numberOfSubContracts = 0;
  }
}
/**
 * This is called to add a contract to our map of supercontracts.
 * @param {map} map - The supercontractsMap to be used.
 * @param {string} superKey - The key of the supercontract.
 * @param {string} contract - The input string defining the contract.
 */


function addToSuperContracts(map, superKey, contract) {
  if (map.has(superKey)) {
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
      for (var _iterator9 = map[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
        var _step9$value = _slicedToArray(_step9.value, 2),
            superContractId = _step9$value[0],
            contractsSet = _step9$value[1];

        if (superContractId === superKey) {
          var newSet = contractsSet;
          newSet.add(contract);
          map.set(superContractId, newSet);
          break;
        }
      }
    } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
          _iterator9["return"]();
        }
      } finally {
        if (_didIteratorError9) {
          throw _iteratorError9;
        }
      }
    }
  } else {
    var newSet = new Set();
    newSet.add(contract);
    map.set(superKey, newSet);
  }

  console.log("SupercontractsMap after adding a contract");
  console.log(map);
}
/**
 * This is called to remove a contract from our map of supercontracts.
 * @param {map} map - The supercontractsMap to be used.
 * @param {string} superKey - The key of the supercontract.
 * @param {string} contract - The input string defining the contract.
 */


function deleteFromSuperContracts(map, superKey, contract) {
  var _iteratorNormalCompletion10 = true;
  var _didIteratorError10 = false;
  var _iteratorError10 = undefined;

  try {
    for (var _iterator10 = map[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
      var _step10$value = _slicedToArray(_step10.value, 2),
          superContractId = _step10$value[0],
          contractsSet = _step10$value[1];

      if (superContractId === superKey) {
        var newSet = contractsSet;
        newSet["delete"](contract);
        map.set(superContractId, newSet);

        if (newSet.size === 0) {
          map["delete"](superContractId);
          document.getElementById("acquire_button_" + superContractId).disabled = true;
        }

        break;
      }
    }
  } catch (err) {
    _didIteratorError10 = true;
    _iteratorError10 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
        _iterator10["return"]();
      }
    } finally {
      if (_didIteratorError10) {
        throw _iteratorError10;
      }
    }
  }

  console.log("SupercontractsMap after deleting a contract");
  console.log(map);
}
/**
 * This is called to execute a given super contract specified by the provided key
 * @param {string} superKey - The key of the supercontract.
 */


function executeSuperContract(superKey) {
  var _iteratorNormalCompletion11 = true;
  var _didIteratorError11 = false;
  var _iteratorError11 = undefined;

  try {
    for (var _iterator11 = superContractsMap[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
      var _step11$value = _slicedToArray(_step11.value, 2),
          superContractId = _step11$value[0],
          contractsSet = _step11$value[1];

      if (superContractId === superKey) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = contractsSet[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var contract = _step12.value;

            if (contract.toBeExecutedAtHorizon !== "yes") {
              executeSingleContract(contract);
            }
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError11 = true;
    _iteratorError11 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
        _iterator11["return"]();
      }
    } finally {
      if (_didIteratorError11) {
        throw _iteratorError11;
      }
    }
  }
}
/**
 * This is called to execute a single lowest-level contract.
 * @param {string} contract - The input string defining the contract.
 */


function executeSingleContract(contract) {
  var obsArr = contract.observablesArr;

  if (obsArr.length > 0) {
    for (var i = 0; i < obsArr.length; ++i) {
      if (obsArr[i] === "libor3m") {
        // rounding because Parity can only handle integers
        contract.amount = Math.round(parseFloat(contract.amount) * (0, _oracles.getOracleByAddress)(agreedOracleAddress).getLiborSpotRate()).toString();
      } else if (obsArr[i] === "tempInLondon") {
        contract.amount = Math.round(parseFloat(contract.amount) * (0, _oracles.getOracleByAddress)(agreedOracleAddress).getTempInLondon()).toString();
      }
    }
  }

  (0, _deploy.holderAddress)().then(function (holderAddress) {
    (0, _deploy.counterPartyAddress)().then(function (counterPartyAddress) {
      if (contract.recipient == 0) {
        // owner receives
        createMoveFile(counterPartyAddress, holderAddress, parseFloat(contract.amount));
        callTransferFunction(contract, counterPartyAddress, holderAddress);
      } else {
        // counter party receives
        createMoveFile(holderAddress, counterPartyAddress, parseFloat(contract.amount));
        callTransferFunction(contract, holderAddress, counterPartyAddress);
      }

      if (document.getElementById("td_status_" + contract.id).innerHTML !== "successful") {
        document.getElementById("td_status_" + contract.id).innerHTML = "not accepted by user";
      }
    });
  });
}
/**
 * This is called to transfer Ether between to accounts.
 * @param {Contract} contract - The Contract object to be used.
 * @param {string} fromAddress - The address to use as sender address.
 * @param {string} toAddress - The address to use as recipient address.
 */


function callTransferFunction(contract, fromAddress, toAddress) {
  (0, _deploy.balanceOfAddress)(fromAddress).then(function (balance) {
    if (balance >= parseFloat(contract.amount)) {
      (0, _deploy.transfer)(fromAddress, toAddress, parseFloat(contract.amount)).then(function (transferTxHash) {
        // do not need to watch for transfer event as we do checks here.. watching the event may cause delays
        (0, _deploy.waitForReceipt)(transferTxHash).then(function (_) {
          console.log(fromAddress + " has transferred " + contract.amount + " Ether to " + toAddress);
          document.getElementById("td_status_" + contract.id).innerHTML = "successful";
          deleteFromSuperContracts(superContractsMap, contract.id.split(".")[0], contract);
          retrieveBalances();
        });
      });
    } else {
      document.getElementById("td_status_" + contract.id).innerHTML = "insufficient funds";

      if ((0, _stringmanipulation.beforeCurrentDate)(contract.horizonDate, "")) {
        document.getElementById("td_status_" + contract.id).innerHTML = "expired";
        deleteFromSuperContracts(superContractsMap, contract.id.split(".")[0], contract);
      }
    }
  });
}
/**
 * This is called to check whether a transactor has sufficient amounts of Ether to execute all pending contracts as well as a newly added contract.
 * @param {Contract} contract - The Contract object to be used.
 * @param {number} balance - The transactor's balance in Ether.
 * @returns {boolean} The boolean specifying whether the transactor has sufficient amounts of Ether.
 */


function enoughBalanceForCapacity(contract, balance) {
  // compute sum of transactions in Map
  var sum = 0;
  var _iteratorNormalCompletion13 = true;
  var _didIteratorError13 = false;
  var _iteratorError13 = undefined;

  try {
    for (var _iterator13 = superContractsMap[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
      var _step13$value = _slicedToArray(_step13.value, 2),
          superContractId = _step13$value[0],
          contractsSet = _step13$value[1];

      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = contractsSet[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var contractInMap = _step14.value;
          sum += parseFloat(contractInMap.amount);
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
            _iterator14["return"]();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError13 = true;
    _iteratorError13 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
        _iterator13["return"]();
      }
    } finally {
      if (_didIteratorError13) {
        throw _iteratorError13;
      }
    }
  }

  if (contract.recipient === 0) {
    // owner is recipient - if sum is +ve then that means holder is receiving and counter party paying
    sum = -sum; // negate the sum for the counterparty
  } // subtract final sum + new tx amount from balance and check if >= 0


  if (balance - (sum + parseFloat(contract.amount)) >= 0) {
    return true;
  } else {
    return false;
  }
}
/**
 * This is called to create a Move IR source code file corresponding to our smart contract transaction.
 * @param {string} sender_address - The address of the sender.
 * @param {string} recipient_address - The address of the recipient.
 * @param {string} amount - The amount to be transferred.
 */


function createMoveFile(sender_address, recipient_address, amount) {
  var textToWrite = "//! no-execute\n" + "import 0x0.LibraAccount;\n" + "import 0x0.LibraCoin;\n \n" + "main(payee: address) {\n" + "\t let coin: R#LibraCoin.T;\n" + "\t let account_exists: bool;\n" + "\t let recipient: address;\n" + "\t let sender: address;\n" + "\t sender = " + sender_address + ";\n" + "\t recipient = " + recipient_address + ";\n" + "\t coin = LibraAccount.withdraw_from_sender(" + amount + ");\n" + "\t account_exists = LibraAccount.exists(copy(recipient));\n" + "\t if (!move(account_exists)) {\n" + "\t \t create_account(copy(recipient));\n" + "\t }\n" + "\t LibraAccount.deposit(move(recipient), move(coin));\n" + "\t return;\n" + "}";
  var textFileAsBlob = new Blob([textToWrite], {
    type: 'text/plain'
  });
  var downloadLink = document.createElement("a");
  downloadLink.download = "script.mvir";
  downloadLink.innerHTML = "Download Move File";

  if (window.webkitURL != null) {
    // Chrome allows the link to be clicked
    // without actually adding it to the DOM.
    downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
  } else {
    // Firefox requires the link to be added to the DOM
    // before it can be clicked.
    downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
    downloadLink.onclick = destroyClickedElement;
    downloadLink.style.display = "none";
    document.body.appendChild(downloadLink);
  }

  downloadLink.click(); // commented for testing purposes

  console.log("Created and downloaded .mvir file.");
}
/**
 * This is called to retrieve the parties' balances in Ether.
 */


function retrieveBalances() {
  (0, _deploy.holderBalance)().then(function (hBalance) {
    document.getElementById("holder_balance_p").innerHTML = "Balance: " + hBalance + "ETH";
    (0, _deploy.counterPartyBalance)().then(function (cBalance) {
      document.getElementById("counter_party_balance_p").innerHTML = "Balance: " + cBalance + "ETH";
    });
  });
}
/**
 * This is called to create a table row inside the table used to present pending contracts.
 * @param {Contract} contract - The contract to be displayed.
 */


function createTableRow(contract) {
  var table = document.getElementById("my_table");
  var tr = table.insertRow(1);
  tr.className = "standard_row";
  var td;
  tr.appendChild(td = document.createElement("td"));
  td.innerHTML = contract.id;
  tr.appendChild(td = document.createElement("td"));
  td.innerHTML = (0, _stringmanipulation.changeDateFormatBack)(contract.contractString);
  tr.appendChild(td = document.createElement("td"));
  td.innerHTML = (0, _stringmanipulation.changeDateFormatBack)(contract.meaningOfContractString);
  tr.appendChild(td = document.createElement("td"));
  td.innerHTML = (0, _stringmanipulation.changeDateFormatBack)(contract.horizonDate);
  tr.appendChild(td = document.createElement("td"));
  td.innerHTML = contract.toBeExecutedAtHorizon;
  tr.appendChild(td = document.createElement("td"));
  td.id = "td_status_" + contract.id;
  td.innerHTML = contract.status;
}
/**
 * This is called to check whether a given transactor owns the rights to make a choice on a disjunct contract.
 * @param {number} contractOwnerInt - A number identifying who the owner of the contract is.
 * @returns {boolean} A boolean value specifying whether the given transactor owns these rights.
 */


function ownsRights(contractOwnerInt) {
  var ownerAddress = contractOwnerInt === 0 ? document.getElementById("holder_address").value : document.getElementById("counter_party_address").value;

  if ((0, _deploy.getSelectedMetaMaskAccount)().toUpperCase() === ownerAddress.toUpperCase()) {
    return true;
  } else {
    document.getElementById("transaction_status").innerHTML = "Please change the currently selected MetaMask account to the owner of the contract you are trying to make a choice on.";
    return false;
  }
}
/**
 * This is called to create a disjunct contract choice button in the UI.
 * @param {string} contractString - The contractString to be used for the button.
 * @param {string} beginningString - The string that will be added to the beginning after a choice has been made.
 * @param {string} endString - The string that will be appended after a choice has been made.
 * @param {number} buttonId - A number identifying the button.
 * @param {number} divId - A number identifying the div element in which the button should be contained.
 * @param {number} owner - A number identifying who the owner of the contract is.
 */


function createButton(contractString, beginningString, endString, buttonId, divId, owner) {
  var button = document.createElement("button");
  button.id = "choices_button_" + buttonId;
  button.className = "choices_button";
  button.innerHTML = (0, _stringmanipulation.cleanParens)(contractString);
  var finalContractString = beginningString + button.innerHTML + endString; // 2. Append somewhere

  var container = document.getElementById("section_" + divId.toString());
  container.appendChild(button); // 3. Add event handler

  button.addEventListener("click", function () {
    if (ownsRights(owner)) {
      // party must own the rights of the contract to make choice
      removeChildren("section_" + divId);
      container.remove();
      processContract(finalContractString, false, true, owner); // firstOrHasBeenDecomposed is true because this is a choice button
    }
  });
}
/**
 * This is called to create a new section inside a given div.
 * @param {number} divId - A number identifying the div element.
 */


function createSection(divId) {
  var div = document.createElement("div");
  div.id = "section_" + divId.toString();
  var para = document.createElement("p");
  var node = document.createTextNode("Contract choice:");
  para.appendChild(node);
  div.appendChild(para);
  var bottomContainer = document.getElementById("button_choices_container");
  bottomContainer.appendChild(div);
}
/**
 * This is called to create an 'or' label inside a given div.
 * @param {number} divId - A number identifying the div element.
 */


function createOrLabel(divId) {
  var para = document.createElement("p");
  para.className = "p_small";
  var node = document.createTextNode("OR");
  para.appendChild(node);
  var container = document.getElementById("section_" + divId.toString());
  container.appendChild(para);
}
/**
 * This is called to remove all children elements of a given container.
 * @param {string} containerString - The container to be used.
 */


function removeChildren(containerString) {
  var e = document.getElementById(containerString);
  var child = e.lastElementChild;

  while (child) {
    e.removeChild(child);
    child = e.lastElementChild;
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./contract.mjs":1,"./deploy/deploy.mjs":2,"./generalfunctions.mjs":4,"./oracles.mjs":6,"./stringmanipulation.mjs":7}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOracles = createOracles;
exports.getOracleByAddress = getOracleByAddress;
exports.Oracle = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * @author Noah-Vincenz Noeh <noah-vincenz.noeh18@imperial.ac.uk>
 */

/* jshint esversion: 6 */
var oracleArr = [];
/**
 * This class defines an Oracle. Every Oracle possesses a unique address and acts as a provider of any observable values for the parties of a contract.
 */

var Oracle =
/*#__PURE__*/
function () {
  // class constructor
  function Oracle(address) {
    _classCallCheck(this, Oracle);

    this.address = address;
  }
  /**
   * Used to return the value of the tempInLondon observable
   */


  _createClass(Oracle, [{
    key: "getTempInLondon",
    value: function getTempInLondon() {
      switch (this.address) {
        case "0x8ce40d9956e7b8a89a1d73f4d4850c760ea20a56":
          return 23;
          break;

        case "0xc90bc8ff4387fe14cdd0934ef9935be590cb83ca":
          return 25;
          break;

        case "0xa03cbbea9891d7961ed23fd965b6ad3109c36a30":
          return 22;
          break;

        case "0x90a3coyea9891d7961edo78h96b6ad3109c3659b":
          return 24;
          break;

        case "0xa89fbjs0033nkkklizqp04bj4jb5bjxxk4nb33n4":
          return 22;
          break;

        default: // code block

      }
    }
    /**
     * Used to return the value of the libor3m observable
     */

  }, {
    key: "getLiborSpotRate",
    value: function getLiborSpotRate() {
      switch (this.address) {
        case "0x8ce40d9956e7b8a89a1d73f4d4850c760ea20a56":
          return 2.26563;
          break;

        case "0xc90bc8ff4387fe14cdd0934ef9935be590cb83ca":
          return 2.25634;
          break;

        case "0xa03cbbea9891d7961ed23fd965b6ad3109c36a30":
          return 2.26551;
          break;

        case "0x90a3coyea9891d7961edo78h96b6ad3109c3659b":
          return 2.25555;
          break;

        case "0xa89fbjs0033nkkklizqp04bj4jb5bjxxk4nb33n4":
          return 2.25420;
          break;

        default: // code block

      }
    }
  }]);

  return Oracle;
}();
/**
 * This is used to create and instantiate a set of Oracle objects.
 */


exports.Oracle = Oracle;

function createOracles() {
  var o1 = new Oracle("0x8ce40d9956e7b8a89a1d73f4d4850c760ea20a56");
  var o2 = new Oracle("0xc90bc8ff4387fe14cdd0934ef9935be590cb83ca");
  var o3 = new Oracle("0xa03cbbea9891d7961ed23fd965b6ad3109c36a30");
  var o4 = new Oracle("0x90a3coyea9891d7961edo78h96b6ad3109c3659b");
  var o5 = new Oracle("0xa89fbjs0033nkkklizqp04bj4jb5bjxxk4nb33n4");
  oracleArr = [o1, o2, o3, o4, o5];
}
/**
 * Used to retrieve an Oracle object by address.
 * @param {string} address - The address of the requested Oracle.
 * @returns {Oracle} The requested Oracle object.
 */


function getOracleByAddress(address) {
  for (var i = 0; i < oracleArr.length; ++i) {
    if (oracleArr[i].address === address) {
      return oracleArr[i];
    }
  }
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanParens = cleanParens;
exports.changeDateFormat = changeDateFormat;
exports.changeDateFormatBack = changeDateFormatBack;
exports.addSpacing = addSpacing;
exports.addParens = addParens;
exports.openingParensAmount = openingParensAmount;
exports.closingParensAmount = closingParensAmount;
exports.lTrimWhiteSpace = lTrimWhiteSpace;
exports.rTrimWhiteSpace = rTrimWhiteSpace;
exports.lTrimParen = lTrimParen;
exports.rTrimParen = rTrimParen;
exports.lTrimBrace = lTrimBrace;
exports.rTrimBrace = rTrimBrace;
exports.lTrimDoubleQuotes = lTrimDoubleQuotes;
exports.rTrimDoubleQuotes = rTrimDoubleQuotes;
exports.trimSemiColon = trimSemiColon;
exports.padNumber = padNumber;
exports.findNextConnective = findNextConnective;
exports.findConsequent = findConsequent;
exports.isDate = isDate;
exports.sameDayAsCurrentDate = sameDayAsCurrentDate;
exports.greaterDate = greaterDate;
exports.equalDates = equalDates;
exports.beforeCurrentDate = beforeCurrentDate;
exports.computeDateString = computeDateString;
exports.concatenate = concatenate;

/**
 * @author Noah-Vincenz Noeh <noah-vincenz.noeh18@imperial.ac.uk>
 */

/* jshint esversion: 6 */

/**
 * Removes incorrect parenthesis from the start and end of a string and returns the modified string.
 * @param {string} str - The contract to modify.
 * @returns {string} The modified contract string.
 */
function cleanParens(str) {
  if (str === undefined) throw new Error("No string argument given.");

  if (str[str.length - 1] === "(") {
    str = str.slice(0, -2);
  }

  if (str[0] === ")") {
    str = str.substr(2);
  }

  var strArr = str.split(" ");

  while (openingParensAmount(str) > closingParensAmount(str) && strArr[0] === "(") {
    str = lTrimParen(str);
    strArr = str.split(" ");
  }

  while (openingParensAmount(str) < closingParensAmount(str) && strArr[strArr.length - 1] === ")") {
    str = rTrimParen(str);
    strArr = str.split(" ");
  }

  return str;
}
/**
 * Changes the date format of a string to one that separates date and time by '-' in order
 * to be able to split a contract by whitespaces.
 * @param {string} str - The contract to modify.
 * @returns {string} The modified contract string.
 */


function changeDateFormat(str) {
  if (str == undefined) throw new Error("No string argument given.");
  var regex = /(.*)(\d\d\d\d)\s(\d\d)(.*)/;
  var matchObj = regex.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + matchObj[2] + "-" + matchObj[3] + matchObj[4];
    matchObj = regex.exec(str);
  }

  return str;
}
/**
 * Changes the date format of a string to one back to the original formate that
 * separates date and time by a whitespace.
 * @param {string} str - The contract to modify.
 * @returns {string} The modified contract string.
 */


function changeDateFormatBack(str) {
  if (str == undefined) throw new Error("No string argument given.");
  var regex = /(.*)(\d\d\d\d)-(\d\d)(.*)/;
  var matchObj = regex.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + matchObj[2] + " " + matchObj[3] + matchObj[4];
    matchObj = regex.exec(str);
  }

  return str;
}
/**
 * Adds spacing before and after parenthesis and curly braces in order to allow
 * splitting of a contract by whitespaces.
 * @param {string} str - The contract to modify.
 * @returns {string} The modified contract string.
 */


function addSpacing(str) {
  if (str == undefined) throw new Error("No string argument given."); // paren spacing

  var regex1 = /(.*\S)(\()(.*)/;
  var matchObj = regex1.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + " " + matchObj[2] + matchObj[3];
    matchObj = regex1.exec(str);
  }

  var regex2 = /(.*\S)(\))(.*)/;
  matchObj = regex2.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + " " + matchObj[2] + matchObj[3];
    matchObj = regex2.exec(str);
  }

  var regex3 = /(.*)(\()(\S.*)/;
  matchObj = regex3.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + matchObj[2] + " " + matchObj[3];
    matchObj = regex3.exec(str);
  }

  var regex4 = /(.*)(\))(\S.*)/;
  matchObj = regex4.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + matchObj[2] + " " + matchObj[3];
    matchObj = regex4.exec(str);
  } // braces spacing


  var regex5 = /(.*\S)({.*)/;
  var matchObj = regex5.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + " " + matchObj[2];
    matchObj = regex5.exec(str);
  }

  var regex6 = /(.*{)([^<>=\s].*)/;
  matchObj = regex6.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + " " + matchObj[2];
    matchObj = regex6.exec(str);
  }

  var regex7 = /(.*[^<>=\s])(}.*)/;
  matchObj = regex7.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + " " + matchObj[2];
    matchObj = regex7.exec(str);
  }

  var regex8 = /(.*})(\S.*)/;
  matchObj = regex8.exec(str);

  while (matchObj !== null) {
    str = matchObj[1] + " " + matchObj[2];
    matchObj = regex8.exec(str);
  }

  return str;
}
/**
 * Adds parenthesis to the front of a string if a string has more closing parens then opening ones,
 * or to the end if it is the other way round.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function addParens(str) {
  if (str == undefined) throw new Error("No string argument given.");

  while (openingParensAmount(str) > closingParensAmount(str)) {
    str = str + " )";
  }

  while (openingParensAmount(str) < closingParensAmount(str)) {
    str = "( " + str;
  }

  return str;
}
/**
 * Counts and returns the number of opening parenthesis contained inside a string.
 * @param {string} str - The string to iterate.
 * @returns {number} The number of opening parenthesis occurrences.
 */


function openingParensAmount(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.split("(").length - 1;
}
/**
 * Counts and returns the number of closing parenthesis contained inside a string.
 * @param {string} str - The string to iterate.
 * @returns {number} The number of closing parenthesis occurrences.
 */


function closingParensAmount(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.split(")").length - 1;
}
/**
 * Removes whitespaces present at the beginning of a string.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function lTrimWhiteSpace(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.replace(/^\s+/g, '');
}
/**
 * Removes whitespaces present at the end of a string.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function rTrimWhiteSpace(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.replace(/\s+$/g, '');
}
/**
 * Removes an opening parenthesis present at the beginning of a string and the following whitespace.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function lTrimParen(str) {
  if (str == undefined) throw new Error("No string argument given.");

  if (str.indexOf("(") === 0) {
    return str.slice(2);
  }

  return str;
}
/**
 * Removes a closing parenthesis present at the end of a string and the preceding whitespace.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function rTrimParen(str) {
  if (str == undefined) throw new Error("No string argument given.");

  if (str.lastIndexOf(")") === str.length - 1) {
    return str.slice(0, -2);
  }

  return str;
}
/**
 * Removes an opening curly brace present at the beginning of a string and the following whitespace.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function lTrimBrace(str) {
  if (str == undefined) throw new Error("No string argument given.");

  if (str.indexOf("{") === 0) {
    return str.slice(2);
  }

  return str;
}
/**
 * Removes a closing curly brace present at the end of a string and the preceding whitespace.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function rTrimBrace(str) {
  if (str == undefined) throw new Error("No string argument given.");

  if (str.lastIndexOf("}") === str.length - 1) {
    return str.slice(0, -2);
  }

  return str;
}
/**
 * Removes double quotes present at the beginning of a string.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function lTrimDoubleQuotes(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.replace(/^\"/, '');
}
/**
 * Removes double quotes present at the end of a string.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function rTrimDoubleQuotes(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.replace(/\"$/, '');
}
/**
 * Removes a single semi-colon present at the end of a string.
 * @param {string} str - The string to modify.
 * @returns {string} The modified string.
 */


function trimSemiColon(str) {
  if (str == undefined) throw new Error("No string argument given.");
  return str.replace(/;$/g, '');
}
/**
 * Pads a given number of length 1 with a zero at the beginning.
 * @param {string} number - The number to be padded.
 * @returns {string} The modified number.
 */


function padNumber(number) {
  if (number.length === 1) {
    return "0" + number;
  }

  return number;
}
/**
 * Used to find the next closest connective inside a given contract string.
 * @param {array} contractStringArr - The given contract string separated by whitespaces.
 * @param {number} indexToStartFrom - The index to start iterating from.
 * @returns {string} The type of the next connective.
 */


function findNextConnective(contractStringArr, indexToStartFrom) {
  for (var i = indexToStartFrom; i < contractStringArr.length; ++i) {
    var term = contractStringArr[i];

    if (term === "and" || term === "or") {
      return term;
    }
  }

  return "";
}
/**
 * Used to find the next closest consequent inside a given contract string.
 * @param {array} contractStringArr - The given contract string separated by whitespaces.
 * @param {number} indexToStartFrom - The index to start iterating from.
 * @returns {array} A pair array containing the consequent string and its size.
 */


function findConsequent(contractStringArr, indexToStartFrom) {
  var returnString = "";

  for (var i = indexToStartFrom; i < contractStringArr.length; ++i) {
    var term = contractStringArr[i];

    if (term === "}") {
      return [returnString, i - indexToStartFrom + 1];
    } else {
      returnString = returnString === "" ? term : returnString + " " + term;
    }
  }

  return ["", 0];
}
/**
 * Used to obtain the next following subcontract string from a given input contract string.
 * @param {array} array - The given contract string separated by whitespaces.
 * @param {number} indexToStartFrom - The index to start iterating from.
 * @returns {array} A pair array containing the subcontract string and its size.
 */


function obtainSubContractString(array, indexToStartFrom) {
  // returns subcontractString and the number of items in the string
  var stringToReturn = "";

  if (array[indexToStartFrom] === "(") {
    var openingParens = 1;

    for (var i = indexToStartFrom + 1; i < array.length; ++i) {
      // if string starts with opening paren wait until get balanced closing paren
      var term = array[i];
      stringToReturn = stringToReturn === "" ? term : stringToReturn + " " + term;

      if (term === "(") {
        ++openingParens;
      } else if (term === ")") {
        --openingParens;
      }

      if (openingParens === 0) {
        return [stringToReturn, i + 1 - indexToStartFrom];
      }
    }
  } else {
    // else wait until reading 'zero' or 'one' OR a number in the case it is called by getValue and has been replaced by a numbe
    for (var i = indexToStartFrom; i < array.length; ++i) {
      var term = array[i];
      stringToReturn = stringToReturn === "" ? term : stringToReturn + " " + term;

      if (term === "one" || term === "zero" || isNumeric(term)) {
        // ---
        return [stringToReturn, i + 1 - indexToStartFrom];
      }
    }
  }
}
/**
 * Used to check whether a given string input is a date
 * @param {string} stringInput - The given string to be checked.
 * @returns {boolean} A boolean value specifying whether the input string corresponds to a date.
 */


function isDate(stringInput) {
  if (stringInput === undefined) {
    return false;
  }

  var matches = stringInput.match(/^((0[1-9])|([12][0-9])|(3[01]))\/((0[1-9])|(1[0-2]))\/(\d\d\d\d)-((0[0-9])|(1[0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])$/);

  if (matches === null) {
    return false;
  } else if (matches[0] === stringInput) {
    return true;
  } else {
    return false;
  }
}
/**
 * Used to check whether a given date is the same day as the current date.
 * @param {string} contractHorizon - The given contract horizon date to be checked.
 * @param {string} horizonToCheck - A date to be compared against instead of the current date (if given).
 * @returns {boolean} A boolean value specifying whether the two dates are the same day.
 */


function sameDayAsCurrentDate(contractHorizon, horizonToCheck) {
  var contractDay = contractHorizon.split("-")[0].split("/")[0],
      contractMonth = contractHorizon.split("-")[0].split("/")[1],
      contractYear = contractHorizon.split("-")[0].split("/")[2];

  if (horizonToCheck === "") {
    var todayDay = new Date().getDate().toString(),
        todayMonth = new Date().getMonth(),
        todayYear = new Date().getFullYear().toString();

    if (contractDay === todayDay && contractMonth === padNumber((todayMonth + 1).toString()) && contractYear === todayYear) {
      return true;
    }

    return false;
  } else {
    var toCompareDay = horizonToCheck.split("-")[0].split("/")[0],
        toCompareMonth = horizonToCheck.split("-")[0].split("/")[1],
        toCompareYear = horizonToCheck.split("-")[0].split("/")[2];

    if (contractDay === toCompareDay && contractMonth === toCompareMonth && contractYear === toCompareYear) {
      return true;
    }

    return false;
  }
}
/**
 * Used to check whether a given date is after another given date.
 * @param {string} dateString1 - The first given contract horizon date.
 * @param {string} dateString2 - The second given contract horizon date.
 * @returns {boolean} A boolean value specifying whether the first date is after the second.
 */


function greaterDate(dateString1, dateString2) {
  // returns true if dateString1 > dateString2
  if (dateString1 === "infinite" || dateString2 === "infinite") {
    if (dateString1 === "infinite" && dateString2 === "infinite") {
      return false;
    } else if (dateString1 === "infinite") {
      return true;
    } else {
      return false;
    }
  } // for first date


  var contractDate1 = new Date(computeDateString(dateString1)); // for second date

  var contractDate2 = new Date(computeDateString(dateString2));

  if (contractDate1.getTime() > contractDate2.getTime()) {
    return true;
  } else {
    return false;
  }
}
/**
 * Used to check whether a two given dates are equivalent.
 * @param {string} dateString1 - The first given contract horizon date.
 * @param {string} dateString2 - The second given contract horizon date.
 * @returns {boolean} A boolean value specifying whether the two dates are the same.
 */


function equalDates(dateString1, dateString2) {
  // for first date
  if (dateString1 === "infinite" || dateString2 === "infinite") {
    if (dateString1 === "infinite" && dateString2 === "infinite") {
      return true;
    } else {
      return false;
    }
  }

  var contractDate1 = new Date(computeDateString(dateString1)); // for second date

  var contractDate2 = new Date(computeDateString(dateString2));

  if (contractDate1.getTime() === contractDate2.getTime()) {
    return true;
  } else {
    return false;
  }
}
/**
 * Used to check whether a given date is before the current date.
 * @param {string} contractDate - The given contract horizon date to be checked.
 * @param {string} horizonToCheck - A date to be compared against instead of the current date (if given).
 * @returns {boolean} A boolean value specifying whether the first date is before the current date.
 */


function beforeCurrentDate(contractDate, horizonToCheck) {
  if (horizonToCheck === "") {
    // we want to compare against the current date - so it is valid even if it is equal to
    if (contractDate === "infinite") {
      return false;
    }

    var contractDate = new Date(computeDateString(contractDate));
    var todayDate = new Date();

    if (contractDate.getTime() < todayDate.getTime()) {
      // Note the =
      return true;
    } else {
      return false;
    }
  } else {
    // we want to compare against another date, not the current date
    if (horizonToCheck === "infinite" || contractDate === "infinite") {
      if (horizonToCheck === "infinite" && contractDate === "infinite") {
        return false;
      } else if (horizonToCheck === "infinite") {
        return true;
      } else {
        return false;
      }
    }

    var contractDate = new Date(computeDateString(contractDate));
    var dateToCompareAgainst = new Date(computeDateString(horizonToCheck));

    if (contractDate.getTime() < dateToCompareAgainst.getTime()) {
      return true;
    } else {
      return false;
    }
  }
}
/**
 * Used to compute a date string in a specified format.
 * @param {string} dateString - The date string to be formatted.
 * @returns {string} The final date string in our desired format.
 */


function computeDateString(dateString) {
  var horizonArr = dateString.split("-"),
      dateArr = horizonArr[0].split("/"),
      timeArr = horizonArr[1].split(":"),
      finalDateString = dateArr[2] + "-" + dateArr[1] + "-" + dateArr[0] + "T" + timeArr[0] + ":" + timeArr[1] + ":" + timeArr[2] + "+01:00"; // adding 15 seconds to the contract's expiry date to allow it to execute

  return finalDateString;
}
/**
 * Used to concatenate two arrays.
 * @param {array} arr1 - The first array used for the concatenation.
 * @param {array} arr2 - The second array used for the concatenation.
 * @returns {array} Our final array.
 */


function concatenate(arr1, arr2) {
  for (var i = 0; i < arr2.length; ++i) {
    arr1.push(arr2[i]);
  }

  return arr1;
}

},{}]},{},[5]);
